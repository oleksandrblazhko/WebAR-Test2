<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Debug - –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∫—Ä–æ–∫—ñ–≤ AR-—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—ó</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
            font-size: 14px;
        }

        .scenes-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .scene {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .scene:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
        }

        .scene-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scene-number {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #000;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .scene-title {
            font-size: 16px;
            font-weight: 600;
        }

        .scene-description {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .scene canvas, .scene video {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: #000;
            display: block;
        }

        .scene-info {
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-size: 11px;
            color: #00d4ff;
        }

        .scene-info span {
            display: block;
            margin: 3px 0;
        }

        .controls {
            max-width: 1400px;
            margin: 20px auto;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-start {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #000;
        }

        .btn-start:hover {
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff4757, #cc3344);
            color: #fff;
        }

        .btn-stop:hover {
            box-shadow: 0 0 20px rgba(255, 71, 87, 0.5);
        }

        .status {
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 13px;
        }

        .status-ready {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .status-running {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .status-error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        /* –ü—Ä–∏—Ö–æ–≤—É—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤–µ –≤—ñ–¥–µ–æ */
        #sourceVideo {
            display: none;
        }
    </style>
</head>
<body>
    <h1>üîç AR Debug - –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∫—Ä–æ–∫—ñ–≤ AR-—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—ó</h1>
    <p class="subtitle">–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—è –æ—Å–Ω–æ–≤–Ω–∏—Ö –µ—Ç–∞–ø—ñ–≤ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è barcode-–º–∞—Ä–∫–µ—Ä—ñ–≤ —Ç–∞ 3D-–≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó</p>

    <!-- –ö–æ–Ω—Ç—Ä–æ–ª–∏ -->
    <div class="controls">
        <button class="btn-start" id="btnStart">‚ñ∂ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –∫–∞–º–µ—Ä—É</button>
        <button class="btn-stop" id="btnStop">‚èπ –ó—É–ø–∏–Ω–∏—Ç–∏</button>
        <div class="status status-ready" id="statusStatus">–ì–æ—Ç–æ–≤–∏–π –¥–æ –∑–∞–ø—É—Å–∫—É</div>
    </div>

    <!-- –í–∏—Ö—ñ–¥–Ω–µ –≤—ñ–¥–µ–æ (–ø—Ä–∏—Ö–æ–≤–∞–Ω–µ) -->
    <video id="sourceVideo" autoplay playsinline muted crossorigin="anonymous"></video>

    <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è 6 —Å—Ü–µ–Ω -->
    <div class="scenes-container">
        <!-- –°—Ü–µ–Ω–∞ 1: –ü–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è -->
        <div class="scene">
            <div class="scene-header">
                <div class="scene-number">1</div>
                <div class="scene-title">–ü–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞</div>
            </div>
            <p class="scene-description">
                RGB ‚Üí Grayscale ‚Üí Gaussian Blur ‚Üí Adaptive Threshold
            </p>
            <canvas id="scene1"></canvas>
            <div class="scene-info" id="scene1Info">
                <span>–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
            </div>
        </div>

        <!-- –°—Ü–µ–Ω–∞ 2: –ü–æ—à—É–∫ –∫–æ–Ω—Ç—É—Ä—ñ–≤ -->
        <div class="scene">
            <div class="scene-header">
                <div class="scene-number">2</div>
                <div class="scene-title">–ü–æ—à—É–∫ –∫–æ–Ω—Ç—É—Ä—ñ–≤</div>
            </div>
            <p class="scene-description">
                –ß–æ—Ç–∏—Ä–∏–∫—É—Ç–Ω–∏–∫–∏, –æ–ø—É–∫–ª—ñ—Å—Ç—å, —Å–ø—ñ–≤–≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω
            </p>
            <canvas id="scene2"></canvas>
            <div class="scene-info" id="scene2Info">
                <span>–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
            </div>
        </div>

        <!-- –°—Ü–µ–Ω–∞ 3: –ü–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω–µ –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è -->
        <div class="scene">
            <div class="scene-header">
                <div class="scene-number">3</div>
                <div class="scene-title">Homography</div>
            </div>
            <p class="scene-description">
                Warp Perspective ‚Üí –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç
            </p>
            <canvas id="scene3"></canvas>
            <div class="scene-info" id="scene3Info">
                <span>–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
            </div>
        </div>

        <!-- –°—Ü–µ–Ω–∞ 4: –î–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è –º–∞—Ä–∫–µ—Ä—ñ–≤ -->
        <div class="scene">
            <div class="scene-header">
                <div class="scene-number">4</div>
                <div class="scene-title">–î–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è</div>
            </div>
            <p class="scene-description">
                –°—ñ—Ç–∫–∞ 3√ó3, –±—ñ–Ω–∞—Ä–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è, ID –º–∞—Ä–∫–µ—Ä–∞
            </p>
            <canvas id="scene4"></canvas>
            <div class="scene-info" id="scene4Info">
                <span>–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
            </div>
        </div>

        <!-- –°—Ü–µ–Ω–∞ 5: Pose Estimation -->
        <div class="scene">
            <div class="scene-header">
                <div class="scene-number">5</div>
                <div class="scene-title">Pose Estimation</div>
            </div>
            <p class="scene-description">
                Rotation Vector (R), Translation Vector (t)
            </p>
            <canvas id="scene5"></canvas>
            <div class="scene-info" id="scene5Info">
                <span>–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
            </div>
        </div>

        <!-- –°—Ü–µ–Ω–∞ 6: 3D –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è -->
        <div class="scene">
            <div class="scene-header">
                <div class="scene-number">6</div>
                <div class="scene-title">3D –ö–æ–Ω—É—Å</div>
            </div>
            <p class="scene-description">
                –ü—Ä–∏–≤'—è–∑–∫–∞ 3D-–ø—Ä–∏–º—ñ—Ç–∏–≤–∞ –¥–æ –º–∞—Ä–∫–µ—Ä–∞
            </p>
            <canvas id="scene6"></canvas>
            <div class="scene-info" id="scene6Info">
                <span>–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
            </div>
        </div>
    </div>

    <!-- OpenCV.js -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>

    <script>
        // ============================================
        // –ì–õ–û–ë–ê–õ–¨–ù–Ü –ó–ú–Ü–ù–ù–Ü
        // ============================================
        let cvReady = false;
        let video = document.getElementById('sourceVideo');
        let stream = null;
        let animationId = null;
        let markerDetected = false;
        let currentMarkerPose = null;

        // Canvas –¥–ª—è —Å—Ü–µ–Ω
        const canvas1 = document.getElementById('scene1');
        const canvas2 = document.getElementById('scene2');
        const canvas3 = document.getElementById('scene3');
        const canvas4 = document.getElementById('scene4');
        const canvas5 = document.getElementById('scene5');
        const canvas6 = document.getElementById('scene6');

        // Contexts –¥–ª—è —Å—Ü–µ–Ω
        const ctx1 = canvas1.getContext('2d');
        const ctx2 = canvas2.getContext('2d');
        const ctx3 = canvas3.getContext('2d');
        const ctx4 = document.getElementById('scene4').getContext('2d');
        const ctx5 = document.getElementById('scene5').getContext('2d');
        const ctx6 = canvas6.getContext('2d');

        // –†–æ–∑–º—ñ—Ä–∏
        const VIDEO_WIDTH = 640;
        const VIDEO_HEIGHT = 480;
        const MARKER_SIZE = 80; // –†–æ–∑–º—ñ—Ä –º–∞—Ä–∫–µ—Ä–∞ –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è

        // ============================================
        // –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø OPENCV
        // ============================================
        function onOpenCvReady() {
            cvReady = true;
            updateStatus('OpenCV –≥–æ—Ç–æ–≤–∏–π. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å "–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –∫–∞–º–µ—Ä—É"', 'ready');
            console.log('‚úÖ OpenCV.js –≥–æ—Ç–æ–≤–∏–π –¥–æ —Ä–æ–±–æ—Ç–∏');
        }

        // ============================================
        // –§–£–ù–ö–¶–Ü–á –£–ü–†–ê–í–õ–Ü–ù–ù–Ø
        // ============================================
        document.getElementById('btnStart').addEventListener('click', startCamera);
        document.getElementById('btnStop').addEventListener('click', stopCamera);

        async function startCamera() {
            if (!cvReady) {
                updateStatus('OpenCV —â–µ –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏–≤—Å—è...', 'error');
                return;
            }

            try {
                // –ó–∞–ø–∏—Ç—É—î–º–æ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: VIDEO_WIDTH },
                        height: { ideal: VIDEO_HEIGHT },
                        facingMode: 'environment' // –ó–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö
                    }
                });

                video.srcObject = stream;
                // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ crossOrigin –¥–ª—è –≤—ñ–¥–µ–æ
                video.crossOrigin = 'anonymous';
                
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                // –ß–µ–∫–∞—î–º–æ –ø–æ–∫–∏ –≤—ñ–¥–µ–æ –¥—ñ–π—Å–Ω–æ –ø–æ—á–Ω–µ –≥—Ä–∞—Ç–∏—Å—è
                await new Promise(resolve => {
                    video.onplay = resolve;
                });

                // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä–∏ canvas
                setupCanvasSizes();

                // –ó–∞–ø—É—Å–∫–∞—î–º–æ —Ü–∏–∫–ª –æ–±—Ä–æ–±–∫–∏
                updateStatus('üé• –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –û–±—Ä–æ–±–∫–∞...', 'running');
                processFrame();

            } catch (err) {
                console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–ø—É—Å–∫—É –∫–∞–º–µ—Ä–∏:', err);
                updateStatus('–ü–æ–º–∏–ª–∫–∞: ' + err.message, 'error');
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            // –û—á–∏—â–∞—î–º–æ —Å—Ü–µ–Ω—É 6
            ctx6.fillStyle = '#1a1a2e';
            ctx6.fillRect(0, 0, canvas6.width, canvas6.height);
            
            updateStatus('–ó—É–ø–∏–Ω–µ–Ω–æ', 'ready');
            markerDetected = false;
            currentMarkerPose = null;
        }

        function setupCanvasSizes() {
            // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –æ–¥–Ω–∞–∫–æ–≤—ñ —Ä–æ–∑–º—ñ—Ä–∏ –¥–ª—è –≤—Å—ñ—Ö canvas
            [canvas1, canvas2, canvas3, canvas4, canvas5, canvas6].forEach(canvas => {
                canvas.width = VIDEO_WIDTH;
                canvas.height = VIDEO_HEIGHT;
            });
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('statusStatus');
            statusEl.textContent = message;
            statusEl.className = 'status status-' + type;
        }

        // ============================================
        // –ì–û–õ–û–í–ù–ò–ô –¶–ò–ö–õ –û–ë–†–û–ë–ö–ò –ö–ê–î–†–Ü–í
        // ============================================
        function processFrame() {
            if (!stream || video.paused || video.ended || !video.videoWidth) return;

            try {
                // –°—Ü–µ–Ω–∞ 1: –ü–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞
                processScene1();

                // –°—Ü–µ–Ω–∞ 2: –ü–æ—à—É–∫ –∫–æ–Ω—Ç—É—Ä—ñ–≤
                const contours = processScene2();

                // –°—Ü–µ–Ω–∞ 3: –ü–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω–µ –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è
                const markerCandidates = processScene3(contours);

                // –°—Ü–µ–Ω–∞ 4: –î–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è –º–∞—Ä–∫–µ—Ä—ñ–≤
                const decodedMarkers = processScene4(markerCandidates);

                // –û—á–∏—â–∞—î–º–æ warped –ø—ñ—Å–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
                markerCandidates.forEach(c => c.warped.delete());

                // –°—Ü–µ–Ω–∞ 5: Pose Estimation
                const poses = processScene5(decodedMarkers);

                // –°—Ü–µ–Ω–∞ 6: 3D –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è
                processScene6(poses);

            } catch (err) {
                console.error('–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –∫–∞–¥—Ä—É:', err);
            }

            animationId = requestAnimationFrame(processFrame);
        }

        // ============================================
        // –°–¶–ï–ù–ê 1: –ü–û–ü–ï–†–ï–î–ù–Ø –û–ë–†–û–ë–ö–ê –ó–û–ë–†–ê–ñ–ï–ù–ù–Ø
        // ============================================
        function processScene1() {
            // –ú–∞–ª—é—î–º–æ –≤—ñ–¥–µ–æ –Ω–∞ canvas
            ctx1.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

            // –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π canvas –¥–ª—è OpenCV
            let tempCanvas = document.createElement('canvas');
            tempCanvas.width = VIDEO_WIDTH;
            tempCanvas.height = VIDEO_HEIGHT;
            let tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
            
            // –û—Ç—Ä–∏–º—É—î–º–æ ImageData –¥–ª—è –æ–±—Ä–æ–±–∫–∏ OpenCV
            let imageData = tempCtx.getImageData(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
            let src = cv.matFromImageData(imageData);
            let dst = new cv.Mat();
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let thresholded = new cv.Mat();

            try {
                // –ö—Ä–æ–∫ 1: RGB ‚Üí Grayscale (–ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è —É –≤—ñ–¥—Ç—ñ–Ω–∫–∏ —Å—ñ—Ä–æ–≥–æ)
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

                // –ö—Ä–æ–∫ 2: Gaussian Blur (–∑–º–µ–Ω—à–µ–Ω–Ω—è —à—É–º—É, —è–¥—Ä–æ 5x5)
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);

                // –ö—Ä–æ–∫ 3: Adaptive Threshold (–±—ñ–Ω–∞—Ä–∏–∑–∞—Ü—ñ—è)
                cv.adaptiveThreshold(blurred, thresholded, 255,
                    cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                    cv.THRESH_BINARY_INV,
                    11, // –†–æ–∑–º—ñ—Ä –±–ª–æ–∫—É
                    2   // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ C
                );

                // –ü–æ–∫–∞–∑—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç (thresholded)
                cv.imshow('scene1', thresholded);

                // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
                document.getElementById('scene1Info').innerHTML = `
                    <span>üìä –†–æ–∑–º—ñ—Ä: ${VIDEO_WIDTH}x${VIDEO_HEIGHT}</span>
                    <span>‚öôÔ∏è Gaussian: —è–¥—Ä–æ 5√ó5</span>
                    <span>üî≤ Adaptive: –±–ª–æ–∫ 11√ó11, C=2</span>
                `;

            } catch (err) {
                console.error('–ü–æ–º–∏–ª–∫–∞ Scene 1:', err);
            } finally {
                src.delete();
                dst.delete();
                gray.delete();
                blurred.delete();
                thresholded.delete();
            }
        }

        // ============================================
        // –°–¶–ï–ù–ê 2: –ü–û–®–£–ö –ö–û–ù–¢–£–†–Ü–í
        // ============================================
        function processScene2() {
            // –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π canvas –¥–ª—è OpenCV
            let tempCanvas = document.createElement('canvas');
            tempCanvas.width = VIDEO_WIDTH;
            tempCanvas.height = VIDEO_HEIGHT;
            let tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
            
            let imageData = tempCtx.getImageData(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
            let src = cv.matFromImageData(imageData);
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let thresholded = new cv.Mat();
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();

            try {
                // –ü–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞ (—è–∫ —É —Å—Ü–µ–Ω—ñ 1)
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                cv.adaptiveThreshold(blurred, thresholded, 255,
                    cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                    cv.THRESH_BINARY_INV,
                    11, 2
                );

                // –ü–æ—à—É–∫ –∫–æ–Ω—Ç—É—Ä—ñ–≤
                cv.findContours(thresholded, contours, hierarchy,
                    cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);

                // –ú–∞–ª—é—î–º–æ –≤–∏—Ö—ñ–¥–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
                ctx2.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

                let quadCount = 0;
                let validQuads = [];

                // –°—Ç–≤–æ—Ä—é—î–º–æ Mat –¥–ª—è –º–∞–ª—é–≤–∞–Ω–Ω—è –∫–æ–Ω—Ç—É—Ä—ñ–≤
                let imgMat = cv.matFromImageData(
                    ctx2.getImageData(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT)
                );

                // –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∫–æ–∂–µ–Ω –∫–æ–Ω—Ç—É—Ä
                for (let i = 0; i < contours.size(); i++) {
                    let contour = contours.get(i);
                    let approx = new cv.Mat();

                    // –ê–ø—Ä–æ–∫—Å–∏–º–∞—Ü—ñ—è –ø–æ–ª—ñ–≥–æ–Ω—É
                    let epsilon = 0.02 * cv.arcLength(contour, true);
                    cv.approxPolyDP(contour, approx, epsilon, true);

                    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Ü–µ —á–æ—Ç–∏—Ä–∏–∫—É—Ç–Ω–∏–∫
                    if (approx.rows === 4) {
                        let area = cv.contourArea(contour);
                        let isConvex = cv.isContourConvex(approx);

                        // –§—ñ–ª—å—Ç—Ä –∑–∞ —Ä–æ–∑–º—ñ—Ä–æ–º (–º—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ –ø–ª–æ—â–∞)
                        if (area > 1000 && area < (VIDEO_WIDTH * VIDEO_HEIGHT) / 4) {
                            // –°–ø—ñ–≤–≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω
                            let rect = cv.boundingRect(contour);
                            let aspectRatio = rect.width / rect.height;

                            // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å–ø—ñ–≤–≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω (–±–ª–∏–∑—å–∫–æ –¥–æ 1 –¥–ª—è –∫–≤–∞–¥—Ä–∞—Ç—ñ–≤)
                            if (aspectRatio > 0.7 && aspectRatio < 1.3 && isConvex) {
                                quadCount++;
                                
                                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Ç–æ—á–æ–∫ –ü–ï–†–ï–î –≤–∏–¥–∞–ª–µ–Ω–Ω—è–º approx
                                let pts = [];
                                for (let j = 0; j < 4; j++) {
                                    pts.push({
                                        x: approx.data32S[j * 2],
                                        y: approx.data32S[j * 2 + 1]
                                    });
                                }
                                
                                validQuads.push({
                                    pts: pts // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ç—ñ–ª—å–∫–∏ –∫–æ–ø—ñ—ó —Ç–æ—á–æ–∫
                                });

                                // –ú–∞–ª—é—î–º–æ –∫–æ–Ω—Ç—É—Ä (–∑–µ–ª–µ–Ω–∏–π –¥–ª—è –≤–∞–ª—ñ–¥–Ω–∏—Ö)
                                let color = new cv.Scalar(0, 255, 0, 255);
                                cv.drawContours(imgMat, contours, i, color, 2,
                                    cv.LINE_8, hierarchy, 100);

                                // –ú–∞–ª—é—î–º–æ —á–µ—Ä–≤–æ–Ω—ñ —Ç–æ—á–∫–∏ –Ω–∞ –∫—É—Ç–∞—Ö –∑ pts
                                for (let pt of pts) {
                                    ctx2.beginPath();
                                    ctx2.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
                                    ctx2.fillStyle = '#ff0000';
                                    ctx2.fill();
                                }
                            }
                        }
                    }
                    approx.delete();
                }

                // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑ –∫–æ–Ω—Ç—É—Ä–∞–º–∏ –Ω–∞–∑–∞–¥ –Ω–∞ canvas
                ctx2.putImageData(cvImageDataFromMat(imgMat), 0, 0);
                imgMat.delete();

                // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
                document.getElementById('scene2Info').innerHTML = `
                    <span>üîç –ó–Ω–∞–π–¥–µ–Ω–æ –∫–æ–Ω—Ç—É—Ä—ñ–≤: ${contours.size()}</span>
                    <span>üî≤ –ß–æ—Ç–∏—Ä–∏–∫—É—Ç–Ω–∏–∫—ñ–≤: ${quadCount}</span>
                    <span>‚úÖ –§—ñ–ª—å—Ç—Ä: –æ–ø—É–∫–ª—ñ—Å—Ç—å + aspect ratio</span>
                `;

                // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –≤–∞–ª—ñ–¥–Ω—ñ —á–æ—Ç–∏—Ä–∏–∫—É—Ç–Ω–∏–∫–∏ –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–∏—Ö —Å—Ü–µ–Ω
                return validQuads;

            } catch (err) {
                console.error('–ü–æ–º–∏–ª–∫–∞ Scene 2:', err);
                return [];
            } finally {
                src.delete();
                gray.delete();
                blurred.delete();
                thresholded.delete();
                contours.delete();
                hierarchy.delete();
            }
        }

        // ============================================
        // –°–¶–ï–ù–ê 3: –ü–ï–†–°–ü–ï–ö–¢–ò–í–ù–ï –í–ò–†–Ü–í–ù–Æ–í–ê–ù–ù–Ø (HOMOGRAPHY)
        // ============================================
        function processScene3(contours) {
            // –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π canvas –¥–ª—è OpenCV
            let tempCanvas = document.createElement('canvas');
            tempCanvas.width = VIDEO_WIDTH;
            tempCanvas.height = VIDEO_HEIGHT;
            let tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
            
            let imageData = tempCtx.getImageData(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
            let src = cv.matFromImageData(imageData);
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let thresholded = new cv.Mat();

            try {
                // –ü–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                cv.adaptiveThreshold(blurred, thresholded, 255,
                    cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                    cv.THRESH_BINARY_INV,
                    11, 2
                );

                // –ú–∞–ª—é—î–º–æ –≤–∏—Ö—ñ–¥–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
                ctx3.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

                let markerCandidates = [];
                const normalizedSize = 200; // –†–æ–∑–º—ñ—Ä –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–æ–≥–æ –∫–≤–∞–¥—Ä–∞—Ç—É
                let markerIndex = 0;

                // –î–ª—è –∫–æ–∂–Ω–æ–≥–æ —á–æ—Ç–∏—Ä–∏–∫—É—Ç–Ω–∏–∫–∞ –≤–∏–∫–æ–Ω—É—î–º–æ warp perspective
                contours.forEach(quad => {
                    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–±–µ—Ä–µ–∂–µ–Ω—ñ —Ç–æ—á–∫–∏ –∑ pts
                    let pts = quad.pts;

                    // –í–ø–æ—Ä—è–¥–∫–æ–≤—É—î–º–æ —Ç–æ—á–∫–∏: topLeft, topRight, bottomRight, bottomLeft
                    let ordered = orderPoints(pts);

                    // –°—Ç–≤–æ—Ä—é—î–º–æ –º–∞—Ç—Ä–∏—Ü—ñ –¥–ª—è warpPerspective
                    let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                        ordered[0].x, ordered[0].y,
                        ordered[1].x, ordered[1].y,
                        ordered[2].x, ordered[2].y,
                        ordered[3].x, ordered[3].y
                    ]);

                    let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                        0, 0,
                        normalizedSize, 0,
                        normalizedSize, normalizedSize,
                        0, normalizedSize
                    ]);

                    // –û–±—á–∏—Å–ª—é—î–º–æ –º–∞—Ç—Ä–∏—Ü—é –≥–æ–º–æ–≥—Ä–∞—Ñ—ñ—ó
                    let M = cv.getPerspectiveTransform(srcTri, dstTri);

                    // –°—Ç–≤–æ—Ä—é—î–º–æ –º–∞—Ç—Ä–∏—Ü—é –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
                    let warped = new cv.Mat();

                    // –í–∏–∫–æ–Ω—É—î–º–æ warp perspective
                    cv.warpPerspective(thresholded, warped, M,
                        new cv.Size(normalizedSize, normalizedSize),
                        cv.INTER_LINEAR,
                        cv.BORDER_CONSTANT,
                        new cv.Scalar(0, 0, 0, 0)
                    );

                    // –ú–∞–ª—é—î–º–æ –ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫ –Ω–∞–≤–∫–æ–ª–æ –º–∞—Ä–∫–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–º—É –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ
                    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ 2D canvas API –∑–∞–º—ñ—Å—Ç—å cv.line
                    ctx3.strokeStyle = '#ffa500'; // –ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π
                    ctx3.lineWidth = 3;
                    ctx3.beginPath();
                    ctx3.moveTo(ordered[0].x, ordered[0].y);
                    ctx3.lineTo(ordered[1].x, ordered[1].y);
                    ctx3.lineTo(ordered[2].x, ordered[2].y);
                    ctx3.lineTo(ordered[3].x, ordered[3].y);
                    ctx3.closePath();
                    ctx3.stroke();

                    // –ú–∞–ª—é—î–º–æ –Ω–æ–º–µ—Ä –º–∞—Ä–∫–µ—Ä–∞
                    markerIndex++;
                    ctx3.fillStyle = '#00ff00';
                    ctx3.font = 'bold 16px Arial';
                    ctx3.fillText(`M${markerIndex}`, ordered[0].x + 5, ordered[0].y + 20);

                    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –º–∞—Ä–∫–µ—Ä–∞ (warped –ù–ï –≤–∏–¥–∞–ª—è—î–º–æ —Ç—É—Ç)
                    markerCandidates.push({
                        pts: pts, // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ç–æ—á–∫–∏
                        warped: warped, // –ù–µ –≤–∏–¥–∞–ª—è—î–º–æ warped, –≤—ñ–Ω –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è –≤ processScene4
                        homography: M,
                        markerIndex: markerIndex
                    });

                    srcTri.delete();
                    dstTri.delete();
                    M.delete();
                    // warped –ù–ï –≤–∏–¥–∞–ª—è—î–º–æ - –≤—ñ–Ω –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è –≤ processScene4
                });

                // –Ø–∫—â–æ –º–∞—Ä–∫–µ—Ä—ñ–≤ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, –ø–æ–∫–∞–∑—É—î–º–æ thresholded
                if (markerCandidates.length === 0) {
                    cv.imshow('scene3', thresholded);
                } else {
                    // –ú–∞–ª—é—î–º–æ –≤—Å—ñ warped –º–∞—Ä–∫–µ—Ä–∏ —É –≤–∏–≥–ª—è–¥—ñ —Å—ñ—Ç–∫–∏
                    drawWarpedMarkersGrid(markerCandidates, normalizedSize);
                }

                // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
                document.getElementById('scene3Info').innerHTML = `
                    <span>üéØ –ö–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤: ${markerCandidates.length}</span>
                    <span>üìê –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è: ${normalizedSize}x${normalizedSize}</span>
                    <span>üîÑ Homography –º–∞—Ç—Ä–∏—Ü—è 3√ó3</span>
                `;

                return markerCandidates;

            } catch (err) {
                console.error('–ü–æ–º–∏–ª–∫–∞ Scene 3:', err);
                return [];
            } finally {
                src.delete();
                gray.delete();
                blurred.delete();
                thresholded.delete();
            }
        }

        /**
         * –ú–∞–ª—é—î —Å—ñ—Ç–∫—É warped –º–∞—Ä–∫–µ—Ä—ñ–≤ –Ω–∞ —Å—Ü–µ–Ω—ñ 3
         */
        function drawWarpedMarkersGrid(markerCandidates, normalizedSize) {
            const cols = 3; // –ö—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ–ª–æ–Ω–æ–∫ —É —Å—ñ—Ç—Ü—ñ
            const rows = Math.ceil(markerCandidates.length / cols);
            const cellSize = Math.min(100, Math.floor(VIDEO_WIDTH / cols));
            const scale = cellSize / normalizedSize;

            // –û—á–∏—â–∞—î–º–æ canvas
            ctx3.fillStyle = '#1a1a2e';
            ctx3.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

            markerCandidates.forEach((candidate, index) => {
                let col = index % cols;
                let row = Math.floor(index / cols);
                let x = col * cellSize + (cellSize - normalizedSize * scale) / 2;
                let y = row * cellSize + 30; // +30 –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞

                // –ú–∞–ª—é—î–º–æ warped –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
                let tempCanvas = document.createElement('canvas');
                tempCanvas.width = normalizedSize;
                tempCanvas.height = normalizedSize;
                let tempCtx = tempCanvas.getContext('2d');
                cv.imshow(tempCanvas, candidate.warped);
                
                ctx3.drawImage(tempCanvas, x, y, normalizedSize * scale, normalizedSize * scale);

                // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –º–∞—Ä–∫–µ—Ä–∞
                ctx3.fillStyle = '#00d4ff';
                ctx3.font = 'bold 12px Arial';
                ctx3.textAlign = 'center';
                ctx3.fillText(`–ú–∞—Ä–∫–µ—Ä #${candidate.markerIndex}`, x + (normalizedSize * scale) / 2, y - 10);

                tempCanvas.remove();
            });
        }

        // ============================================
        // –°–¶–ï–ù–ê 4: –î–ï–ö–û–î–£–í–ê–ù–ù–Ø –ú–ê–†–ö–ï–†–Ü–í
        // ============================================
        function processScene4(markerCandidates) {
            const decodedMarkers = [];
            const gridSize = 3; // –°—ñ—Ç–∫–∞ 3x3 –¥–ª—è barcode-–º–∞—Ä–∫–µ—Ä–∞
            const cellSize = Math.floor(200 / gridSize); // 66.67 –ø—ñ–∫—Å–µ–ª—ñ–≤ –Ω–∞ –∫–ª—ñ—Ç–∏–Ω–∫—É

            // –Ø–∫—â–æ –º–∞—Ä–∫–µ—Ä—ñ–≤ –Ω–µ–º–∞—î, –ø–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            if (markerCandidates.length === 0) {
                document.getElementById('scene4Info').innerHTML = `
                    <span>‚è≥ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –º–∞—Ä–∫–µ—Ä–∞...</span>
                `;
                // –û—á–∏—â–∞—î–º–æ —Å—Ü–µ–Ω—É
                ctx4.fillStyle = '#1a1a2e';
                ctx4.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
                return decodedMarkers;
            }

            // –ú–∞–ª—é—î–º–æ —Å—ñ—Ç–∫—É –¥–µ–∫–æ–¥–æ–≤–∞–Ω–∏—Ö –º–∞—Ä–∫–µ—Ä—ñ–≤
            drawDecodedMarkersGrid(markerCandidates, gridSize, cellSize);

            markerCandidates.forEach((candidate, index) => {
                // –°—Ç–≤–æ—Ä—é—î–º–æ –∫–æ–ø—ñ—é warped –¥–ª—è –æ–±—Ä–æ–±–∫–∏
                let warped = candidate.warped.clone();
                let ordered = orderPoints(candidate.pts); // –í–ø–æ—Ä—è–¥–∫–æ–≤—É—î–º–æ —Ç–æ—á–∫–∏

                // –ó—á–∏—Ç—É—î–º–æ –±—ñ–Ω–∞—Ä–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –∫–ª—ñ—Ç–∏–Ω
                let binaryGrid = [];
                let binaryString = '';

                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ü–µ–Ω—Ç—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏
                        let centerX = Math.floor((col + 0.5) * cellSize);
                        let centerY = Math.floor((row + 0.5) * cellSize);

                        // –ó—á–∏—Ç—É—î–º–æ –ø—ñ–∫—Å–µ–ª—å –∑ —Ü–µ–Ω—Ç—Ä—É
                        let pixel = warped.ucharAt(centerY, centerX);

                        // –ë—ñ–Ω–∞—Ä–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è (255 = 1, 0 = 0)
                        let binaryValue = pixel > 127 ? 1 : 0;
                        binaryGrid.push(binaryValue);
                        binaryString += binaryValue.toString();
                    }
                }

                // –û–±—á–∏—Å–ª—é—î–º–æ ID –º–∞—Ä–∫–µ—Ä–∞ (—Å–ø—Ä–æ—â–µ–Ω–æ)
                // –î–ª—è 3x3 –º–∞—Ä–∫–µ—Ä–∞: –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ 5 –±—ñ—Ç—ñ–≤ –∫–æ–¥—É—é—Ç—å ID
                // –Ü–≥–Ω–æ—Ä—É—î–º–æ –∫—É—Ç–æ–≤—ñ –º–∞—Ä–∫–µ—Ä–∏ –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó
                let idBits = [
                    binaryGrid[1], // row 0, col 1
                    binaryGrid[3], // row 1, col 0
                    binaryGrid[4], // row 1, col 1 (—Ü–µ–Ω—Ç—Ä)
                    binaryGrid[5], // row 1, col 2
                    binaryGrid[7]  // row 2, col 1
                ];

                let markerId = parseInt(idBits.join(''), 2);

                decodedMarkers.push({
                    id: markerId,
                    corners: ordered,
                    binary: binaryGrid,
                    binaryString: binaryString,
                    markerIndex: candidate.markerIndex
                });

                // –í–∏–¥–∞–ª—è—î–º–æ –∫–æ–ø—ñ—é warped –ø—ñ—Å–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
                warped.delete();
            });

            return decodedMarkers;
        }

        /**
         * –ú–∞–ª—é—î —Å—ñ—Ç–∫—É –¥–µ–∫–æ–¥–æ–≤–∞–Ω–∏—Ö –º–∞—Ä–∫–µ—Ä—ñ–≤ –Ω–∞ —Å—Ü–µ–Ω—ñ 4
         */
        function drawDecodedMarkersGrid(markerCandidates, gridSize, cellSize) {
            const cols = 3; // –ö—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ–ª–æ–Ω–æ–∫ —É —Å—ñ—Ç—Ü—ñ
            const markerDisplaySize = 120; // –†–æ–∑–º—ñ—Ä –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è –º–∞—Ä–∫–µ—Ä–∞
            const gap = 10; // –í—ñ–¥—Å—Ç—É–ø –º—ñ–∂ –º–∞—Ä–∫–µ—Ä–∞–º–∏

            // –û—á–∏—â–∞—î–º–æ canvas
            ctx4.fillStyle = '#1a1a2e';
            ctx4.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

            markerCandidates.forEach((candidate, index) => {
                let col = index % cols;
                let row = Math.floor(index / cols);
                let baseX = col * (markerDisplaySize + gap) + gap;
                let baseY = row * (markerDisplaySize + gap + 80) + gap; // +80 –¥–ª—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó

                // –ú–∞–ª—é—î–º–æ warped –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
                let tempCanvas = document.createElement('canvas');
                tempCanvas.width = 200;
                tempCanvas.height = 200;
                let tempCtx = tempCanvas.getContext('2d');
                cv.imshow(tempCanvas, candidate.warped);
                
                // –ú–∞—Å—à—Ç–∞–±—É—î–º–æ –¥–æ markerDisplaySize
                ctx4.drawImage(tempCanvas, baseX, baseY, markerDisplaySize, markerDisplaySize);

                // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –º–∞—Ä–∫–µ—Ä–∞
                ctx4.fillStyle = '#00d4ff';
                ctx4.font = 'bold 12px Arial';
                ctx4.textAlign = 'center';
                ctx4.fillText(`–ú–∞—Ä–∫–µ—Ä #${candidate.markerIndex}`, baseX + markerDisplaySize / 2, baseY - 10);

                // –ú–∞–ª—é—î–º–æ —Å—ñ—Ç–∫—É 3x3 –ø–æ–≤–µ—Ä—Ö –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
                ctx4.strokeStyle = '#00ff00';
                ctx4.lineWidth = 1;
                let displayCellSize = markerDisplaySize / gridSize;

                for (let i = 0; i <= gridSize; i++) {
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ñ –ª—ñ–Ω—ñ—ó
                    ctx4.beginPath();
                    ctx4.moveTo(baseX + i * displayCellSize, baseY);
                    ctx4.lineTo(baseX + i * displayCellSize, baseY + markerDisplaySize);
                    ctx4.stroke();

                    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ñ –ª—ñ–Ω—ñ—ó
                    ctx4.beginPath();
                    ctx4.moveTo(baseX, baseY + i * displayCellSize);
                    ctx4.lineTo(baseX + markerDisplaySize, baseY + i * displayCellSize);
                    ctx4.stroke();
                }

                // –ó—á–∏—Ç—É—î–º–æ —Ç–∞ –º–∞–ª—é—î–º–æ –±—ñ–Ω–∞—Ä–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
                let warped = candidate.warped;
                let binaryGrid = [];
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        let centerX = Math.floor((col + 0.5) * (200 / gridSize));
                        let centerY = Math.floor((row + 0.5) * (200 / gridSize));
                        let pixel = warped.ucharAt(centerY, centerX);
                        let binaryValue = pixel > 127 ? 1 : 0;
                        binaryGrid.push(binaryValue);

                        // –ú–∞–ª—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞ —Å—ñ—Ç—Ü—ñ (–º–∞—Å—à—Ç–∞–±–æ–≤–∞–Ω–µ)
                        ctx4.fillStyle = pixel > 127 ? '#00ff00' : '#ff0000';
                        ctx4.font = 'bold 10px Arial';
                        ctx4.textAlign = 'center';
                        ctx4.textBaseline = 'middle';
                        ctx4.fillText(binaryValue.toString(),
                            baseX + col * displayCellSize + displayCellSize / 2,
                            baseY + row * displayCellSize + displayCellSize / 2);
                    }
                }

                // –û–±—á–∏—Å–ª—é—î–º–æ ID –º–∞—Ä–∫–µ—Ä–∞
                let idBits = [
                    binaryGrid[1], binaryGrid[3], binaryGrid[4], binaryGrid[5], binaryGrid[7]
                ];
                let markerId = parseInt(idBits.join(''), 2);

                // –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –º–∞—Ä–∫–µ—Ä
                ctx4.fillStyle = '#ffffff';
                ctx4.font = '11px Arial';
                ctx4.textAlign = 'center';
                ctx4.fillText(`ID: ${markerId}`, baseX + markerDisplaySize / 2, baseY + markerDisplaySize + 15);
                
                let binaryString = binaryGrid.join('');
                ctx4.fillStyle = '#888888';
                ctx4.font = '9px Arial';
                ctx4.fillText(`Bin: ${binaryString.substring(0, 9)}`, baseX + markerDisplaySize / 2, baseY + markerDisplaySize + 30);

                tempCanvas.remove();
            });

            // –û–Ω–æ–≤–ª—é—î–º–æ –∑–∞–≥–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
            document.getElementById('scene4Info').innerHTML = `
                <span>üéØ –ó–Ω–∞–π–¥–µ–Ω–æ –º–∞—Ä–∫–µ—Ä—ñ–≤: ${markerCandidates.length}</span>
                <span>üìä –°—ñ—Ç–∫–∞: ${gridSize}√ó${gridSize}</span>
                <span>üî¢ –ë—ñ–Ω–∞—Ä–Ω–µ –¥–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è</span>
            `;
        }

        // ============================================
        // –°–¶–ï–ù–ê 5: POSE ESTIMATION
        // ============================================
        function processScene5(decodedMarkers) {
            const poses = [];

            // –ú–∞–ª—é—î–º–æ –≤–∏—Ö—ñ–¥–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
            ctx5.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

            // –Ø–∫—â–æ –º–∞—Ä–∫–µ—Ä—ñ–≤ –Ω–µ–º–∞—î
            if (decodedMarkers.length === 0) {
                document.getElementById('scene5Info').innerHTML = `
                    <span>‚è≥ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –º–∞—Ä–∫–µ—Ä–∞...</span>
                `;
                markerDetected = false;
                currentMarkerPose = null;
                return poses;
            }

            let markerIndex = 0;

            decodedMarkers.forEach((marker, index) => {
                let corners = marker.corners; // –¶–µ pts –∑ processScene2

                // –í—ñ–¥–æ–º–∏–π —Ä–æ–∑–º—ñ—Ä –º–∞—Ä–∫–µ—Ä–∞ (—É –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–∏—Ö –æ–¥–∏–Ω–∏—Ü—è—Ö)
                const markerSize = 1.0;

                // 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∫—É—Ç—ñ–≤ –º–∞—Ä–∫–µ—Ä–∞ (—É –ø—Ä–æ—Å—Ç–æ—Ä—ñ –æ–±'—î–∫—Ç–∞)
                let objectPoints = cv.matFromArray(4, 1, cv.CV_32FC3, [
                    -markerSize / 2, markerSize / 2, 0,   // topLeft
                    markerSize / 2, markerSize / 2, 0,    // topRight
                    markerSize / 2, -markerSize / 2, 0,   // bottomRight
                    -markerSize / 2, -markerSize / 2, 0   // bottomLeft
                ]);

                // 2D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∫—É—Ç—ñ–≤ (—É –ø—Ä–æ—Å—Ç–æ—Ä—ñ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è)
                let imagePoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    corners[0].x, corners[0].y,
                    corners[1].x, corners[1].y,
                    corners[2].x, corners[2].y,
                    corners[3].x, corners[3].y
                ]);

                // –ú–∞—Ç—Ä–∏—Ü—è –∫–∞–º–µ—Ä–∏ (–ø—Ä–∏–±–ª–∏–∑–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è 640x480)
                let cameraMatrix = cv.matFromArray(3, 3, cv.CV_32FC1, [
                    VIDEO_WIDTH, 0, VIDEO_WIDTH / 2,
                    0, VIDEO_WIDTH, VIDEO_HEIGHT / 2,
                    0, 0, 1
                ]);

                // –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ –¥–∏—Å—Ç–æ—Ä—Å—ñ—ó (–ø—Ä–∏–π–º–∞—î–º–æ –Ω—É–ª—å–æ–≤–∏–º–∏)
                let distCoeffs = cv.matFromArray(5, 1, cv.CV_32FC1, [0, 0, 0, 0, 0]);

                // –í–µ–∫—Ç–æ—Ä–∏ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
                let rvec = cv.matFromArray(3, 1, cv.CV_32FC1, [0, 0, 0]);
                let tvec = cv.matFromArray(3, 1, cv.CV_32FC1, [0, 0, 0]);

                try {
                    // SolvePnP: –∑–Ω–∞—Ö–æ–¥–∏–º–æ rotation vector —Ç–∞ translation vector
                    let success = cv.solvePnP(objectPoints, imagePoints,
                        cameraMatrix, distCoeffs, rvec, tvec);

                    if (success) {
                        markerIndex++;

                        // –ú–∞–ª—é—î–º–æ –æ—Å—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–∞ –º–∞—Ä–∫–µ—Ä—ñ
                        drawAxis(ctx5, corners[0], rvec, tvec, cameraMatrix, distCoeffs);

                        // –ú–∞–ª—é—î–º–æ –Ω–æ–º–µ—Ä —Ç–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–∞—Ä–∫–µ—Ä
                        ctx5.fillStyle = '#00ff00';
                        ctx5.font = 'bold 14px Arial';
                        ctx5.fillText(`M${markerIndex}`, corners[0].x + 10, corners[0].y + 10);

                        // –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –ø–æ–∑—É
                        let infoY = corners[2].y + 25;
                        ctx5.fillStyle = '#00d4ff';
                        ctx5.font = '11px Arial';
                        ctx5.fillText(`R: [${rvec.data32F[0].toFixed(1)}, ${rvec.data32F[1].toFixed(1)}, ${rvec.data32F[2].toFixed(1)}]`, corners[0].x + 10, infoY);
                        ctx5.fillText(`t: [${tvec.data32F[0].toFixed(1)}, ${tvec.data32F[1].toFixed(1)}, ${tvec.data32F[2].toFixed(1)}]`, corners[0].x + 10, infoY + 15);

                        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–∑—É –¥–ª—è —Å—Ü–µ–Ω–∏ 6
                        poses.push({
                            rvec: [rvec.data32F[0], rvec.data32F[1], rvec.data32F[2]],
                            tvec: [tvec.data32F[0], tvec.data32F[1], tvec.data32F[2]],
                            corners: corners,
                            markerIndex: markerIndex
                        });

                        // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –¥–ª—è –ø–µ—Ä—à–æ–≥–æ –º–∞—Ä–∫–µ—Ä–∞
                        if (index === 0) {
                            document.getElementById('scene5Info').innerHTML = `
                                <span>üîÑ R: [${rvec.data32F[0].toFixed(2)}, ${rvec.data32F[1].toFixed(2)}, ${rvec.data32F[2].toFixed(2)}]</span>
                                <span>üìç t: [${tvec.data32F[0].toFixed(2)}, ${tvec.data32F[1].toFixed(2)}, ${tvec.data32F[2].toFixed(2)}]</span>
                                <span>üéØ –ú–∞—Ä–∫–µ—Ä—ñ–≤: ${decodedMarkers.length}</span>
                            `;

                            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω—É –ø–æ–∑—É
                            currentMarkerPose = poses[0];
                            markerDetected = true;
                        }
                    }
                } catch (err) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ SolvePnP:', err);
                } finally {
                    objectPoints.delete();
                    imagePoints.delete();
                    cameraMatrix.delete();
                    distCoeffs.delete();
                    rvec.delete();
                    tvec.delete();
                }
            });

            // –û–Ω–æ–≤–ª—é—î–º–æ –∑–∞–≥–∞–ª—å–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
            if (poses.length > 0) {
                document.getElementById('scene5Info').innerHTML = `
                    <span>üéØ –ó–Ω–∞–π–¥–µ–Ω–æ –º–∞—Ä–∫–µ—Ä—ñ–≤: ${poses.length}</span>
                    <span>üîÑ Pose Estimation (POSIT)</span>
                    <span>üìç R & t –≤–µ–∫—Ç–æ—Ä–∏</span>
                `;
            }

            return poses;
        }

        // ============================================
        // –°–¶–ï–ù–ê 6: 3D –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–Ø (–ö–û–ù–£–°)
        // ============================================
        function processScene6(poses) {
            // –ú–∞–ª—é—î–º–æ –≤—ñ–¥–µ–æ-–ø–æ—Ç—ñ–∫ –Ω–∞ —Ñ–æ–Ω—ñ
            ctx6.drawImage(video, 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);

            // –Ø–∫—â–æ –º–∞—Ä–∫–µ—Ä—ñ–≤ –Ω–µ–º–∞—î
            if (poses.length === 0) {
                document.getElementById('scene6Info').innerHTML = `
                    <span>‚è≥ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –º–∞—Ä–∫–µ—Ä–∞...</span>
                    <span>üî∫ –ö–æ–Ω—É—Å –ø—Ä–∏—Ö–æ–≤–∞–Ω–∏–π</span>
                `;
                return;
            }

            // –ú–∞–ª—é—î–º–æ –∫–æ–Ω—É—Å –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –º–∞—Ä–∫–µ—Ä–∞
            poses.forEach(pose => {
                drawCone2D(
                    ctx6,
                    pose.corners,
                    pose.tvec,
                    pose.markerIndex
                );
            });

            // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
            document.getElementById('scene6Info').innerHTML = `
                <span>üî∫ –ö–æ–Ω—É—Å—ñ–≤: ${poses.length}</span>
                <span>üéØ –ú–∞—Ä–∫–µ—Ä—ñ–≤: ${poses.length}</span>
                <span>üìç 3D –ø—Ä–∏–≤'—è–∑–∫–∞</span>
            `;
        }

        /**
         * –ú–∞–ª—é—î 3D –∫–æ–Ω—É—Å –Ω–∞ 2D canvas
         * @param {CanvasRenderingContext2D} ctx
         * @param {Array} corners - 4 –∫—É—Ç–∏ –º–∞—Ä–∫–µ—Ä–∞
         * @param {Array} tvec - –≤–µ–∫—Ç–æ—Ä –ø–æ–∑–∏—Ü—ñ—ó
         * @param {number} markerIndex - –Ω–æ–º–µ—Ä –º–∞—Ä–∫–µ—Ä–∞
         */
        function drawCone2D(ctx, corners, tvec, markerIndex) {
            // –í–ø–æ—Ä—è–¥–∫–æ–≤—É—î–º–æ –∫—É—Ç–∏
            let ordered = orderPoints(corners);

            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ü–µ–Ω—Ç—Ä –º–∞—Ä–∫–µ—Ä–∞
            let centerX = (ordered[0].x + ordered[1].x + ordered[2].x + ordered[3].x) / 4;
            let centerY = (ordered[0].y + ordered[1].y + ordered[2].y + ordered[3].y) / 4;

            // –†–æ–∑–º—ñ—Ä –∫–æ–Ω—É—Å–∞ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –≤—ñ–¥—Å—Ç–∞–Ω—ñ (tvec[2])
            let coneHeight = Math.min(80, 150 / (Math.abs(tvec[2]) + 0.5));
            let coneRadius = coneHeight * 0.4;

            // –í–µ—Ä—à–∏–Ω–∞ –∫–æ–Ω—É—Å–∞ (–∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –ø–æ–∑–∏—Ü—ñ—ó)
            let apexX = centerX - tvec[0] * 50;
            let apexY = centerY - coneHeight - tvec[1] * 50;

            // –ú–∞–ª—é—î–º–æ –∫–æ–Ω—É—Å —è–∫ —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫ –∑ –µ–ª—ñ–ø—Å–æ–º –≤ –æ—Å–Ω–æ–≤—ñ
            ctx.save();

            // –¢—ñ–Ω—å –∫–æ–Ω—É—Å–∞
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + 5, coneRadius, coneRadius * 0.3, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fill();

            // –û—Å–Ω–æ–≤–∞ –∫–æ–Ω—É—Å–∞ (–µ–ª—ñ–ø—Å)
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, coneRadius, coneRadius * 0.5, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 212, 255, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // –ë—ñ—á–Ω—ñ —Å—Ç–æ—Ä–æ–Ω–∏ –∫–æ–Ω—É—Å–∞ (—Ç—Ä–∏–∫—É—Ç–Ω–∏–∫)
            ctx.beginPath();
            ctx.moveTo(apexX, apexY);
            ctx.lineTo(centerX - coneRadius, centerY);
            ctx.lineTo(centerX + coneRadius, centerY);
            ctx.closePath();

            // –ì—Ä–∞–¥—ñ—î–Ω—Ç –¥–ª—è –∫–æ–Ω—É—Å–∞
            let gradient = ctx.createLinearGradient(apexX, apexY, centerX, centerY);
            gradient.addColorStop(0, 'rgba(0, 212, 255, 0.9)');
            gradient.addColorStop(1, 'rgba(0, 153, 204, 0.7)');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // –í–µ—Ä—à–∏–Ω–∞
            ctx.beginPath();
            ctx.arc(apexX, apexY, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();

            // –ù–æ–º–µ—Ä –º–∞—Ä–∫–µ—Ä–∞
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`M${markerIndex}`, apexX + 10, apexY - 10);

            ctx.restore();
        }

        // ============================================
        // –î–û–ü–û–ú–Ü–ñ–ù–Ü –§–£–ù–ö–¶–Ü–á
        // ============================================

        /**
         * –ö–æ–Ω–≤–µ—Ä—Ç—É—î cv.Mat —É ImageData –¥–ª—è putImageData
         */
        function cvImageDataFromMat(mat) {
            let imageData = new ImageData(mat.cols, mat.rows);
            let data = imageData.data;
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–∞–Ω–∞–ª—ñ–≤
            let channels = mat.channels();
            
            for (let i = 0; i < mat.rows; i++) {
                for (let j = 0; j < mat.cols; j++) {
                    let idx = (i * mat.cols + j) * 4;
                    if (channels === 1) {
                        // –í—ñ–¥—Ç—ñ–Ω–∫–∏ —Å—ñ—Ä–æ–≥–æ
                        let pixel = mat.ucharAt(i, j);
                        data[idx] = pixel;     // R
                        data[idx + 1] = pixel; // G
                        data[idx + 2] = pixel; // B
                        data[idx + 3] = 255;   // A
                    } else if (channels === 4) {
                        // RGBA
                        let ptr = mat.ptr(i, j);
                        data[idx] = ptr[0];     // B (OpenCV –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î BGR)
                        data[idx + 1] = ptr[1]; // G
                        data[idx + 2] = ptr[2]; // R
                        data[idx + 3] = ptr[3]; // A
                    }
                }
            }
            return imageData;
        }

        /**
         * –í–ø–æ—Ä—è–¥–∫–æ–≤—É—î —Ç–æ—á–∫–∏ —á–æ—Ç–∏—Ä–∏–∫—É—Ç–Ω–∏–∫–∞: topLeft, topRight, bottomRight, bottomLeft
         */
        function orderPoints(pts) {
            // –°—É–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç: topLeft –º–∞—î –Ω–∞–π–º–µ–Ω—à—É, bottomRight - –Ω–∞–π–±—ñ–ª—å—à—É
            let sum = pts.map(p => p.x + p.y);
            let diff = pts.map(p => p.x - p.y);

            let topLeft = pts[sum.indexOf(Math.min(...sum))];
            let bottomRight = pts[sum.indexOf(Math.max(...sum))];
            let topRight = pts[diff.indexOf(Math.max(...diff))];
            let bottomLeft = pts[diff.indexOf(Math.min(...diff))];

            return [topLeft, topRight, bottomRight, bottomLeft];
        }

        /**
         * –ú–∞–ª—é—î 3D –æ—Å—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–∞ –º–∞—Ä–∫–µ—Ä—ñ
         */
        function drawAxis(ctx, origin, rvec, tvec, cameraMatrix, distCoeffs) {
            // –ü—Ä–æ—Å—Ç–∞ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –æ—Å–µ–π –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é 2D canvas
            // –û—Å–∏: X - —á–µ—Ä–≤–æ–Ω–∏–π, Y - –∑–µ–ª–µ–Ω–∏–π, Z - —Å–∏–Ω—ñ–π
            
            // –ú–∞–ª—é—î–º–æ –≤—ñ—Å—å X (—á–µ—Ä–≤–æ–Ω–∏–π)
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(origin.x + 50, origin.y);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('X', origin.x + 55, origin.y);
            
            // –ú–∞–ª—é—î–º–æ –≤—ñ—Å—å Y (–∑–µ–ª–µ–Ω–∏–π)
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(origin.x, origin.y + 50);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#00ff00';
            ctx.fillText('Y', origin.x, origin.y + 55);
            
            // –ú–∞–ª—é—î–º–æ –≤—ñ—Å—å Z (—Å–∏–Ω—ñ–π) - –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∞
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(origin.x - 30, origin.y - 30);
            ctx.strokeStyle = '#0000ff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#0000ff';
            ctx.fillText('Z', origin.x - 45, origin.y - 35);
        }
    </script>
</body>
</html>
