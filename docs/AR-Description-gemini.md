# Аналіз алгоритму роботи barcode-маркерів у WebAR-проекті

## Загальний огляд (Executive Summary)

Цей документ детально розбирає, як WebAR-проект перетворює зображення з камери на 3D-об'єкти, що прив'язані до фізичних маркерів.

**Ключовий процес:**
1.  **Захоплення:** Відеопотік з камери пристрою безперервно аналізується.
2.  **Розпізнавання:** Бібліотека **AR.js** знаходить у кадрі спеціальні **barcode-маркери** та ідентифікує їх за унікальним номером (ID).
3.  **Обчислення позиції:** За допомогою алгоритму **POSIT**, система визначає точне положення маркера у 3D-просторі (координати та обертання) відносно камери.
4.  **Візуалізація:** Бібліотека **Three.js** використовує ці дані, щоб "намалювати" відповідний 3D-об'єкт (наприклад, конус) точно над розпізнаним маркером, створюючи ілюзію доповненої реальності.

Цей аналіз розкриває кожен етап, від ініціалізації системи до фінального рендерингу сцени.

## Вступ

Цей документ описує алгоритм обробки даних від barcode-маркерів у WebAR-проекті, який використовує бібліотеку **AR.js** (artoolkit) для розпізнавання маркерів та **Three.js** для 3D-візуалізації.

---

## 1. Архітектура системи

### 1.1. Основні компоненти

```
index.html (головний файл)
├── AR.js / artoolkit (ядро розпізнавання маркерів)
├── threex/ (обгортка для інтеграції з Three.js)
│   ├── threex-artoolkitsource.js (джерело відео з камери)
│   ├── threex-artoolkitcontext.js (контекст AR-сесії)
│   ├── threex-arbasecontrols.js (базовий клас контролерів)
│   └── threex-armarkercontrols.js (контролери маркерів)
└── Three.js (3D-візуалізація)
```

### 1.2. Ключові файли

| Файл | Призначення |
|------|-------------|
| `index.html` | Головна логіка додатку, ініціалізація AR, завантаження контенту |
| `threex-artoolkitcontext.js` | Контекст AR-сесії, ініціалізація artoolkit/aruco бекендів |
| `threex-armarkercontrols.js` | Управління окремими маркерами (pattern, barcode) |
| `js/ar.js` | AR.js бібліотека (artoolkit) - низькорівневе розпізнавання |

---

## 2. Алгоритм обробки barcode-маркерів

### 2.1. Етап 1: Ініціалізація AR-контексту

**Файл:** `index.html` (функція `initialize()`)

```javascript
// ... (визначення canvasWidth, canvasHeight) ...

// Створення AR-контексту з параметрами
arToolkitContext = new THREEx.ArToolkitContext({
    trackingBackend: 'artoolkit',      // Використовуємо AR.js
    detectionMode: 'mono_and_matrix',  // Режим детектування
    matrixCodeType: "3x3",             // Тип barcode-маркера
    maxDetectionRate: -1,              // Вимикаємо обмеження частоти
    canvasWidth: canvasWidth,          // З конфігурації (640/1280)
    canvasHeight: canvasHeight         // З конфігурації (480/720)
});

// ... (ініціалізація arToolkitContext) ...
```

**Що відбувається:**
1. Завантажується конфігурація з `config.json`.
2. Визначається роздільна здатність на основі `config.settings.resolution`.
3. Створюється екземпляр `THREEx.ArToolkitContext`.
4. **Встановлюються ключові параметри детектування:**
    - `detectionMode: 'mono_and_matrix'` — вказує AR.js шукати одночасно і звичайні (`mono`), і матричні (`matrix`) маркери.
    - `matrixCodeType: "3x3"` — визначає тип barcode-маркера, який система буде розпізнавати.
    - `maxDetectionRate: -1` — це налаштування вимикає обмеження на частоту розпізнавання кадрів.
        - **Чому це важливо:** це дозволяє досягти максимальної плавності руху 3D-об'єктів, оскільки їх позиція оновлюється на кожному доступному кадрі (до 60 FPS).
        - **Компроміс:** це створює постійне високе навантаження на процесор, що може призводити до швидкого розряду батареї та нагрівання пристрою, особливо на мобільних телефонах.
5. Після ініціалізації AR-контексту, матриця проекції 3D-камери копіюється з AR.js, щоб забезпечити правильну перспективу.

---

### 2.2. Етап 2: Створення контролера barcode-маркера

**Файл:** `index.html` (цикл створення маркерів)

```javascript
// Для кожного barcode-маркера з конфігурації
if (markerConfig.type === 'barcode') {
    let markerControls = new THREEx.ArMarkerControls(
        arToolkitContext,     // AR-контекст
        markerRoots[i],       // 3D-група для цього маркера
        {
            type: "barcode",
            barcodeValue: markerConfig.target,  // ID маркера (напр., 1, 2, 3)
        }
    );
}
```
**Що відбувається:**
1. Для кожного маркера типу `barcode` з конфігурації створюється об'єкт `THREEx.ArMarkerControls`.
2. Цей об'єкт пов'язує AR-контекст, 3D-об'єкт-контейнер (`markerRoots[i]`) та унікальний ID маркера (`barcodeValue`).
3. Кожен створений контролер автоматично реєструється в `arToolkitContext` для подальшого відстеження.

---

### 2.3. Етап 3: Реєстрація та обчислення позиції маркера (POSIT)

**Ключовий файл:** `threex-armarkercontrols.js`

**Що відбувається:**
1.  Після ініціалізації, контролер маркера викликає `arController.trackBarcodeMarkerId()`, реєструючи ID маркера в ядрі AR.js.
2.  Встановлюється слухач подій `getMarker`, який спрацьовує щоразу, коли AR.js знаходить будь-який маркер у кадрі.
3.  Коли знайдено маркер із потрібним ID, система отримує від AR.js готову **матрицю трансформації** (`modelViewMatrix`).
4.  **Створення цієї матриці — "магія" AR.js, яка виконується за допомогою алгоритму POSIT:**
    - **POSIT (Pose from Orthography and Scaling with ITeration)** — це класичний алгоритм комп'ютерного зору для визначення 3D-пози з 2D-зображення.
    - **Вхідні дані:**
        - 4 кутові точки маркера на 2D-зображенні (в пікселях).
        - Реальний розмір маркера (напр., 80мм), вказаний у коді.
        - Параметри камери (фокусна відстань, центр проекції).
    - **Як працює (спрощено):**
        1.  **Починає з припущення ортографічної проекції** (без перспективи), що спрощує початкові розрахунки.
        2.  **Ітеративно уточнює позицію**, додаючи ефект перспективи (віддалені точки здаються ближчими одна до одної). На кожному кроці алгоритм мінімізує помилку між реальними 2D-координатами кутів та їх проекціями, обчисленими на основі поточної оцінки позиції.
        3.  **Результат** (зазвичай через 4-8 ітерацій) — готова матриця 4x4, що містить точну позицію (X, Y, Z) та обертання маркера відносно камери.

    **Приклад результату роботи POSIT для маркера 3x3:**
    ```
    ФІНАЛЬНА МАТРИЦЯ 4×4 (modelViewMatrix):
    ┌                                              ┐
    │  0.985  -0.165   0.052   0.12  │  X-позиція
    │  0.028   0.098  -0.995   0.05  │  Y-позиція
    │ -0.170  -0.985  -0.035   0.45  │  Z-позиція
    │  0.000   0.000   0.000   1.00  │  Однорідна
    └                                              ┘
    
    ІНТЕРПРЕТАЦІЯ:
    - Маркер знаходиться на відстані 45 см від камери (Z=0.45).
    - Зміщений на 12 см праворуч (X=0.12) і на 5 см вище (Y=0.05) центру огляду камери.
    - Решта елементів матриці кодують складне обертання маркера у просторі.
    ```
5.  Ця матриця передається далі для оновлення 3D-сцени.

---

### 2.4. Етап 4: Обробка кадрів та детектування

**Файл:** `threex-artoolkitcontext.js` (метод `update`)

```javascript
ARjs.Context.prototype.update = function(srcElement) {
    // ... (перевірка частоти детектування) ...
    
    // Ховаємо всі маркери перед обробкою нового кадру
    this._arMarkersControls.forEach(function(markerControls) {
        markerControls.object3d.visible = false;
    });
    
    // Передаємо кадр з камери до AR.js для обробки
    this.arController.process(srcElement);
};
```
**Що відбувається:**
1. Кожен кадр з камери передається в `arController.process()`. Це найресурсоємніша операція.
2. Ядро AR.js шукає на зображенні маркери (`detectMarker`).
3. Для кожного знайденого маркера обчислюється його матриця трансформації (як описано в Етапі 3).
4. **Застосовується оптимізація:**
    - Якщо маркер **щойно з'явився**, використовується повний розрахунок позиції (`getTransMatSquare`).
    - Якщо маркер **вже відстежувався** в попередньому кадрі, використовується "гладкий" розрахунок (`getTransMatSquareCont`), який швидший і дає менше тремтіння, бо спирається на попередню позицію.
5. Для кожного розпізнаного маркера генерується подія `getMarker`, що містить його матрицю.

---

### 2.5. Етап 5: Оновлення позиції 3D-об'єкта

**Файл:** `threex-armarkercontrols.js` (метод `updateWithModelViewMatrix`)

**Що відбувається:**
1. Отримана матриця з AR.js **трансформується** для сумісності з системою координат Three.js (вони використовують різні напрямки осей).
2. Матриця копіюється в 3D-об'єкт-контейнер (`markerObject3D.matrix`).
3. Three.js автоматично **декомпозує** матрицю на знайомі властивості: `position`, `quaternion` (обертання) та `scale`.
4. Об'єкт-контейнер стає видимим (`markerObject3D.visible = true`), і всі дочірні 3D-моделі (наш конус) миттєво з'являються у правильному місці.

---

### 2.6. Етап 6: Візуалізація 3D-примітива (конус)

**Файл:** `index.html`

**Що відбувається:**
1. На етапі ініціалізації для маркера створюється геометрія конуса (`THREE.ConeGeometry`) та матеріал.
2. Геометрія трохи зміщується (`geometry.translate`), щоб її основа, а не центр, знаходилась у точці (0,0,0) контейнера. Це гарантує, що конус буде стояти "на" маркері, а не "в" ньому.
3. Готовий 3D-об'єкт (`mesh`) додається до відповідного контейнера `markerRoots[i]`. Він залишається невидимим, поки не буде знайдено його маркер.

---

## 3. Аналіз продуктивності та "вузькі місця"

Продуктивність є критичним фактором для WebAR-додатків, особливо на мобільних пристроях.

### 3.1. Основне навантаження

- **Центральний процесор (CPU):** Найбільш ресурсоємною операцією є обробка кожного кадру відео для пошуку та аналізу маркерів. Функція `arController.process(srcElement)` виконує складні обчислення з комп'ютерного зору і є головним "вузьким місцем".

### 3.2. Вплив налаштувань

- **Роздільна здатність (`canvasWidth`, `canvasHeight`):**
    - **Висока (1280x720):** Покращує точність розпізнавання на великих відстанях, але значно збільшує навантаження на CPU. Це може призводити до падіння FPS (кадрів за секунду) та менш плавної роботи.
    - **Низька (640x480):** Зменшує навантаження, забезпечуючи вищий FPS, але може погіршити розпізнавання дрібних або віддалених маркерів.

- **Частота детектування (`maxDetectionRate`):**
    - Значення `-1` змушує систему обробляти кожен кадр, що забезпечує максимальну плавність, але й максимальне навантаження.
    - Обмеження цього значення (наприклад, до 30) може значно зменшити споживання ресурсів, але рух об'єктів стане менш плавним ("ривками").

### 3.3. Оптимізації в коді

- **Плавне відстеження (`getTransMatSquareCont`):** Коли маркер вже знайдений, система використовує цей метод, який спирається на позицію з попереднього кадру. Це значно швидше, ніж обчислювати позицію "з нуля" (`getTransMatSquare`) на кожному кадрі, і є ключовою оптимізацією для стабільного відстеження.

---

## 4. Повний цикл обробки даних

### 4.1. Діаграма потоку даних

```
┌────────────────────────────────┐
│      КАМЕРА (відеопотік)       │
└────────────────────────────────┘
               │
               ▼
┌────────────────────────────────┐
│   arController.process()       │
│ (пошук маркерів, розрахунок    │
│  матриці за алгоритмом POSIT)  │
└────────────────────────────────┘
               │ (подія 'getMarker' з матрицею)
               ▼
┌────────────────────────────────┐
│  ArMarkerControls (слухач)     │
│ (перевірка ID, оновлення сцени)│
└────────────────────────────────┘
               │
               ▼
┌────────────────────────────────┐
│  Three.js (renderer.render)    │
│ (візуалізація 3D-об'єкта       │
│    на основі матриці)          │
└────────────────────────────────┘
```

---

### 4.2. Послідовність подій у часі

| Час | Подія |
|-----|-------|
| T0 | Ініціалізація AR-контексту та камери. |
| T1 | Створення контролерів для кожного barcode-маркера. |
| T2 | Реєстрація маркерів у AR.js (`trackBarcodeMarkerId`). |
| T3 | **Цикл обробки кадрів (до 60 FPS):** |
| T3.1| - `arController.process()` обробляє кадр. |
| T3.2| - Якщо маркер знайдено, генерується подія `getMarker`. |
| T3.3| - Слухач подій в `ArMarkerControls` отримує матрицю. |
| T3.4| - `updateWithModelViewMatrix()` оновлює позицію 3D-об'єкта. |
| T3.5| - `renderer.render()` візуалізує оновлену сцену. |

---

## 5. Приклад: Конус на barcode-маркері

### 5.1. Конфігурація (config.json)

```json
{
  "markers": [
    {
      "type": "barcode",
      "target": 1,
      "contentType": "primitive",
      "primitive": {
        "type": "ConeGeometry",
        "radius": 0.5,
        "height": 1,
        "color": "#ff0000"
      }
    }
  ]
}
```

### 5.2. Що відбувається при виявленні маркера з ID=1

1. **Камера** захоплює зображення з barcode-маркером.
2. **AR.js** розпізнає маркер з `idMatrix = 1`.
3. **Обчислюється** матриця трансформації (позиція + обертання).
4. **Оновлюється** позиція `markerRoots[0]` (контейнер для маркера 1).
5. **Візуалізується** червоний конус, що прив'язаний до цього контейнера.

---

## 6. Ключові відмінності barcode від pattern-маркерів

| Характеристика | Barcode-маркер | Pattern-маркер |
|----------------|----------------|----------------|
| **Тип розпізнавання** | Матричний код (3x3, 4x4) | Зображення-шаблон (.patt файл) |
| **Ідентифікація** | За числовим ID (`idMatrix`) | За завантаженим шаблоном (`idPatt`) |
| **Реєстрація** | `trackBarcodeMarkerId(id, size)` | `loadMarker(url)` + `trackPatternMarkerId(id)` |
| **Гнучкість** | Висока (будь-яке числове ID) | Низька (потрібен .patt файл для кожного) |

---

## 7. Висновки

### 7.1. Переваги barcode-маркерів у AR.js

- **Простота:** не потрібні окремі файли шаблонів.
- **Гнучкість:** можна використовувати будь-які числові ID.
- **Швидкість:** матричне розпізнавання зазвичай швидше за шаблонне.

### 7.2. Недоліки

- **Обмежена кількість:** залежить від типу матриці (напр., 3x3 — 512 варіацій).
- **Залежність від друку:** якість друку впливає на розпізнавання.

### 7.3. Чому додано ArUco-маркери

Aruco-маркери є сучаснішою альтернативою, яка вирішує багато недоліків старих підходів (більше унікальних ID, краща стійкість до спотворень), але в цьому проекті вони поки що не інтегровані в єдиний потік обробки з AR.js.

---

## 8. Глосарій термінів

| Термін | Визначення |
|--------|------------|
| **AR.js** | Бібліотека для доповненої реальності у вебі, заснована на ARToolKit. |
| **Barcode-маркер** | Матричний код (наприклад, 3x3), що ідентифікується за числовим ID. |
| **ModelViewMatrix** | Матриця 4x4, що описує позицію та обертання об'єкта у 3D-просторі. |
| **POSIT** | Алгоритм для визначення 3D-позиції об'єкта за його 2D-проекцією. |
| **Three.js** | Бібліотека для 3D-графіки у вебі. |
| **THREEx** | Розширення для Three.js, що спрощують інтеграцію з AR.js. |

---

## Додаток A: Посилання на файли

- **Головний файл:** `index.html`
- **AR.js бібліотека:** `js/ar.js`
- **AR-контекст:** `threex/threex-artoolkitcontext.js`
- **Контролери маркерів:** `threex/threex-armarkercontrols.js`

---

*Документ оновлено та доповнено на основі критичного аналізу.*
