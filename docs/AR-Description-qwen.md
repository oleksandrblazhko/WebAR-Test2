# Аналіз алгоритму роботи barcode-маркерів у WebAR-проекті

## Вступ

Цей документ описує алгоритм обробки даних від barcode-маркерів у WebAR-проекті, який використовує бібліотеку **AR.js** (artoolkit) для розпізнавання маркерів та **Three.js** для 3D-візуалізації.

---

## Зміст

1. [Архітектура системи](#1-архітектура-системи)
2. [Алгоритм обробки barcode-маркерів](#2-алгоритм-обробки-barcode-маркерів)
   - [2.0. Етап 0: Математичні основи — Обчислення матриці трансформації](#20-етап-0-математичні-основи--обчислення-матриці-трансформації)
     - [Вхідні дані](#201-вхідні-дані-для-обчислення-матриці)
     - [Обчислення гомографії](#202-обчислення-гомографії-3x3)
     - [Розкладання гомографії](#203-розкладання-гомографії-на-r-обертання-та-t-позиція)
     - [Формування матриці 3x4](#204-формування-матриці-3x4-rt)
     - [Конвертація у Three.js 4x4](#205-конвертація-у-формат-threejs-4x4)
     - [getTransMatSquare vs getTransMatSquareCont](#206-gettransmatsquare-vs-gettransmatsquarecont)
     - [Повний ланцюжок обчислень](#207-повний-ланцюжок-обчислень)
   - [2.1. Етап 1: Ініціалізація AR-контексту](#21-етап-1-ініціалізація-ar-контексту)
   - [2.2. Етап 2: Створення контролера barcode-маркера](#22-етап-2-створення-контролера-barcode-маркера)
   - [2.3. Етап 3: Реєстрація маркера в AR.js](#23-етап-3-реєстрація-маркера-v-arjs)
   - [2.4. Етап 4: Обробка кадрів та детектування](#24-етап-4-обробка-кадрів-та-детектування)
   - [2.5. Етап 5: Оновлення позиції 3D-об'єкта](#25-етап-5-оновлення-позиції-3d-обєкта)
   - [2.6. Етап 6: Візуалізація 3D-примітива](#26-етап-6-візуалізація-3d-примітива-конус)
3. [Повний цикл обробки даних](#3-повний-цикл-обробки-даних)
4. [Приклад: Конус на barcode-маркері](#4-приклад-конус-на-barcode-маркері)
5. [Відмінності barcode від pattern-маркерів](#5-ключові-відмінності-barcode-від-pattern-маркерів)
6. [Висновки](#6-висновки)
7. [Глосарій](#7-глосарій-термінів)

---

## 1. Архітектура системи

### 1.1. Основні компоненти

```
index.html (головний файл)
├── AR.js / artoolkit (ядро розпізнавання маркерів)
├── threex/ (обгортка для інтеграції з Three.js)
│   ├── threex-artoolkitsource.js (джерело відео з камери)
│   ├── threex-artoolkitcontext.js (контекст AR-сесії)
│   ├── threex-arbasecontrols.js (базовий клас контролерів)
│   └── threex-armarkercontrols.js (контролери маркерів)
└── Three.js (3D-візуалізація)
```

### 1.2. Ключові файли

| Файл | Призначення |
|------|-------------|
| `index.html` | Головна логіка додатку, ініціалізація AR, завантаження контенту |
| `threex-artoolkitcontext.js` | Контекст AR-сесії, ініціалізація artoolkit/aruco бекендів |
| `threex-armarkercontrols.js` | Управління окремими маркерами (pattern, barcode) |
| `js/ar.js` | AR.js бібліотека (artoolkit) - низькорівневе розпізнавання |

---

## 2. Алгоритм обробки barcode-маркерів

### 2.0. Етап 0: Математичні основи — Обчислення матриці трансформації

**Файл:** `js/ar.js` (виклик C++ функції через WebAssembly)

ARToolKit використовує **алгоритм оцінки пози для планарних об'єктів через гомографію**, а не класичний POSIT, тому що:
- **POSIT вимагає 4 НЕ-копланарних точки** (не лежать в одній площині)
- **Кути квадратного маркера лежать в одній площині** (Z=0 у системі координат маркера)

---

#### **2.0.1. Вхідні дані для обчислення матриці**

```
┌─────────────────────────────────────────────────────────────┐
│                    ВХІДНІ ДАНІ                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 2D-координати кутів маркера (пікселі):                  │
│     vertex[0] = (x₀, y₀)  // Верхній лівий                  │
│     vertex[1] = (x₁, y₁)  // Верхній правий                 │
│     vertex[2] = (x₂, y₂)  // Нижній правий                  │
│     vertex[3] = (x₃, y₃)  // Нижній лівий                   │
│                                                             │
│  2. 3D-координати кутів маркера (метри, відносно центру):   │
│     Точка 0: (-w/2,  h/2, 0)  // w = h = markerWidth        │
│     Точка 1: ( w/2,  h/2, 0)                                │
│     Точка 2: ( w/2, -h/2, 0)                                │
│     Точка 3: (-w/2, -h/2, 0)                                │
│                                                             │
│  3. Параметри камери (з camera_para.dat):                   │
│     fx, fy  — фокусні відстані (пікселі)                    │
│     cx, cy  — оптичний центр (пікселі)                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

#### **2.0.2. Обчислення гомографії (3x3)**

**Гомографія H** — це матриця 3x3, яка трансформує точки з площини маркера у площину зображення:

```
[u]       [X]
|v| ≈ H * |Y|
[w]       [1]

Де:
- (X, Y) — 3D координати на площині маркера (Z=0)
- (u, v) — 2D координати на зображенні (пікселі)
- w — масштабний множник (глибина)

Після нормалізації:
u_pixel = u / w
v_pixel = v / w
```

**Приклад гомографії для маркера 80мм на відстані 45см:**

```
H = [  0.523  -0.087   245  ]
    [  0.012   0.531   180  ]
    [  0.0003 -0.0002   1   ]

Трансформація точки (-0.04, 0.04, 0):
┌     ┐   ┌                      ┐   ┌        ┐   ┌     ┐
│ u'  │   │  0.523  -0.087   245 │   │ -0.04  │   │ 241.5 │
│ v'  │ = │  0.012   0.531   180 │ * │  0.04  │ = │ 180.2 │
│ w'  │   │  0.0003 -0.0002   1  │   │  1     │   │ 0.999 │
└     ┘   └                      ┘   └        ┘   └     ┘

u = 241.5 / 0.999 ≈ 242 пікселі
v = 180.2 / 0.999 ≈ 180 пікселів
```

---

#### **2.0.3. Розкладання гомографії на R (обертання) та t (позиція)**

```
┌─────────────────────────────────────────────────────────────┐
│         РОЗКЛАДАННЯ H НА R (ОБЕРТАННЯ) ТА t (ПОЗИЦІЯ)       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Нормалізація з урахуванням параметрів камери:           │
│     H' = K^(-1) * H                                         │
│     Де K — матриця внутрішніх параметрів:                   │
│     ┌              ┐                                        │
│     │ fx  0   cx  │                                        │
│     │ 0   fy  cy  │                                        │
│     │ 0   0   1   │                                        │
│     └              ┘                                        │
│                                                             │
│  2. Вилучення векторів r1, r2 (стовпці H'):                 │
│     r1 = перший стовпець H'                                 │
│     r2 = другий стовпець H'                                 │
│                                                             │
│  3. Обчислення r3 (вектор нормалі до площини):              │
│     r3 = r1 × r2  (векторний добуток)                       │
│                                                             │
│  4. Нормалізація для отримання ортонормованої матриці:      │
│     scale = (||r1|| + ||r2||) / 2                           │
│     R = [r1/scale, r2/scale, r3/scale]                      │
│                                                             │
│  5. Обчислення вектора позиції t:                           │
│     t = третій стовпець H' / scale                          │
│     t = [tx, ty, tz]                                        │
│                                                             │
│  6. Корекція знаку (щоб маркер був перед камерою):          │
│     Якщо tz < 0, то R = -R, t = -t                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

#### **2.0.4. Формування матриці 3x4 [R|t]**

```
Матриця 3x4 (transMat):
┌                                      ┐
│  R[0,0]  R[0,1]  R[0,2]  tx  │
│  R[1,0]  R[1,1]  R[1,2]  ty  │
│  R[2,0]  R[2,1]  R[2,2]  tz  │
└                                      ┘

Приклад (маркер на відстані 45 см):
┌                                              ┐
│  0.985  -0.165   0.052   0.12  │  X = 12 см  │
│  0.028   0.098  -0.995   0.05  │  Y = 5 см   │
│ -0.170  -0.985  -0.035   0.45  │  Z = 45 см  │
└                                              ┘
```

---

#### **2.0.5. Конвертація у формат Three.js (4x4)**

**Функція `transMatToGLMat`** (`js/ar.js`, рядок ~48):

```javascript
ARController.prototype.transMatToGLMat = (function(transMat, glMat, scale) {
    // transMat — це 3x4 [R|t] з C++ (12 елементів)
    // glMat — це 4x4 для WebGL/Three.js (16 елементів)
    
    // Копіювання R (3x3) у стовпчиковому порядку
    glMat[0+0*4] = transMat[0];   // R[0,0]
    glMat[0+1*4] = transMat[1];   // R[1,0]
    glMat[0+2*4] = transMat[2];   // R[2,0]
    glMat[0+3*4] = transMat[3];   // 0
    
    glMat[1+0*4] = transMat[4];   // R[0,1]
    glMat[1+1*4] = transMat[5];   // R[1,1]
    glMat[1+2*4] = transMat[6];   // R[2,1]
    glMat[1+3*4] = transMat[7];   // 0
    
    glMat[2+0*4] = transMat[8];   // R[0,2]
    glMat[2+1*4] = transMat[9];   // R[1,2]
    glMat[2+2*4] = transMat[10];  // R[2,2]
    glMat[2+3*4] = transMat[11];  // 0
    
    // Останній рядок завжди [0, 0, 0, 1]
    glMat[3+0*4] = 0;
    glMat[3+1*4] = 0;
    glMat[3+2*4] = 0;
    glMat[3+3*4] = 1;
    
    // Позиція (translation)
    if (scale != undefined && scale !== 0) {
        glMat[12] = transMat[12] * scale;  // X
        glMat[13] = transMat[13] * scale;  // Y
        glMat[14] = transMat[14] * scale;  // Z
    }
    
    return glMat;
});
```

**Фінальна матриця 4x4 для Three.js:**

```
┌                                              ┐
│  0.985  -0.165   0.052   0.12  │  X           │
│  0.028   0.098  -0.995   0.05  │  Y           │
│ -0.170  -0.985  -0.035   0.45  │  Z           │
│  0.000   0.000   0.000   1.00  │  Однорідна   │
└                                              ┘
```

---

#### **2.0.6. getTransMatSquare vs getTransMatSquareCont**

| Характеристика | `getTransMatSquare` | `getTransMatSquareCont` |
|----------------|---------------------|-------------------------|
| **Початкове наближення** | Немає (з нуля) | Попередня матриця |
| **Ітерацій** | 4-6 | 1-2 |
| **Стабільність** | Середня (може стрибати) | Висока (плавно) |
| **Швидкодія** | Повільніше | Швидше |
| **Коли використовується** | Маркер щойно з'явився | Маркер відстежується кілька кадрів |
| **Джиттер позиції** | ~2-5 мм | ~0.5-1 мм |

**`getTransMatSquareCont`** використовує матрицю з попереднього кадру як початкове наближення, що забезпечує:
- Менше "джиттеру" (плавніше відстеження)
- Більшу стабільність при частковому перекритті
- Менше ітерацій для збіжності (1-2 замість 4-6)

---

#### **2.0.7. Повний ланцюжок обчислень**

```
┌─────────────────────────────────────────────────────────────┐
│                    ПОВНИЙ ЛАНЦЮЖОК                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. КАМЕРА: 640x480 пікселів                                │
│     ┌─────────────────────────────────────────────┐        │
│     │  ┌─────────────────────────────────┐        │        │
│     │  │  [242,180] ●───────● [392,185]  │        │        │
│     │  │            │       │            │        │        │
│     │  │            │  ███  │            │        │        │
│     │  │            │  ███  │            │        │        │
│     │  │            │       │            │        │        │
│     │  │  [238,300] ●───────● [388,305]  │        │        │
│     │  └─────────────────────────────────┘        │        │
│     └─────────────────────────────────────────────┘        │
│                                                             │
│  2. ОБЧИСЛЕННЯ ГОМОГРАФІЇ:                                  │
│     H = [ 0.523  -0.087   245  ]                            │
│         [ 0.012   0.531   180  ]                            │
│         [ 0.0003 -0.0002   1   ]                            │
│                                                             │
│  3. РОЗКЛАДАННЯ (з K^(-1)):                                 │
│     R = [ 0.985  -0.165   0.052 ]                           │
│         [ 0.028   0.098  -0.995 ]                           │
│         [-0.170  -0.985  -0.035 ]                           │
│                                                             │
│     t = [0.12, 0.05, 0.45]  (метри)                         │
│                                                             │
│  4. МАТРИЦЯ 3x4 (transMat):                                 │
│     [ 0.985  -0.165   0.052   0.12 ]                        │
│     [ 0.028   0.098  -0.995   0.05 ]                        │
│     [-0.170  -0.985  -0.035   0.45 ]                        │
│                                                             │
│  5. МАТРИЦЯ 4x4 (glMat для Three.js):                       │
│     ┌                                              ┐        │
│     │  0.985  -0.165   0.052   0.12  │  X           │        │
│     │  0.028   0.098  -0.995   0.05  │  Y           │        │
│     │ -0.170  -0.985  -0.035   0.45  │  Z           │        │
│     │  0.000   0.000   0.000   1.00  │  Однорідна   │        │
│     └                                              ┘        │
│                                                             │
│  6. THREE.JS:                                               │
│     markerRoot.position.set(0.12, 0.05, 0.45)               │
│     markerRoot.quaternion.setFromRotationMatrix(glMat)      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 2.1. Етап 1: Ініціалізація AR-контексту

**Файл:** `index.html` (функція `initialize()`)

```javascript
// Визначаємо роздільну здатність з конфігурації
let canvasWidth = 640;
let canvasHeight = 480;

if (config && config.settings) {
    switch(config.settings.resolution) {
        case 'high':
            canvasWidth = 1280;
            canvasHeight = 720;
            break;
        case 'low':
        default:
            canvasWidth = 640;
            canvasHeight = 480;
            break;
    }
}

// Створення AR-контексту з параметрами
arToolkitContext = new THREEx.ArToolkitContext({
    trackingBackend: 'artoolkit',      // Використовуємо AR.js
    detectionMode: 'mono_and_matrix',  // Режим детектування
    matrixCodeType: "3x3",             // Тип barcode-маркера
    maxDetectionRate: -1,              // Вимикаємо обмеження частоти
    canvasWidth: canvasWidth,          // З конфігурації (640/1280)
    canvasHeight: canvasHeight         // З конфігурації (480/720)
});

// Ініціалізація контексту
arToolkitContext.init(function onCompleted() {
    // Копіюємо матрицю проекції камери
    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
});
```

**Що відбувається:**
1. Завантажується конфігурація з `config.json`
2. Визначається роздільна здатність на основі `config.settings.resolution`:
   - `'high'` → 1280x720
   - `'low'` або за замовчуванням → 640x480
3. Створюється екземпляр `THREEx.ArToolkitContext` з динамічно визначеними параметрами
4. Встановлюються параметри детектування (тип маркера, роздільна здатність)
5. Після ініціалізації отримуємо матрицю проекції камери для правильної 3D-візуалізації

---

### 2.2. Етап 2: Створення контролера barcode-маркера

**Файл:** `index.html` (цикл створення маркерів)

```javascript
// Для кожного barcode-маркера з конфігурації
if (markerConfig.type === 'barcode') {
    let markerControls = new THREEx.ArMarkerControls(
        arToolkitContext,     // AR-контекст
        markerRoots[i],       // 3D-група для цього маркера
        {
            type: "barcode",
            barcodeValue: markerConfig.target,  // ID маркера (напр., 1, 2, 3)
        }
    );
}
```

**Файл:** `threex-armarkercontrols.js` (конструктор `ArMarkerControls`)

```javascript
ARjs.MarkerControls = THREEx.ArMarkerControls = function(context, object3d, parameters) {
    // Зберігаємо параметри маркера
    this.parameters = {
        type: 'barcode',
        barcodeValue: null,  // ID barcode-маркера
        size: 1,             // Розмір маркера в метрах
    };
    
    // Додаємо маркер до контексту
    context.addMarker(this);
    
    // Ініціалізація для artoolkit бекенду
    if (context.parameters.trackingBackend === 'artoolkit') {
        this._initArtoolkit();
    }
};
```

**Що відбувається:**
1. Створюється об'єкт `THREEx.ArMarkerControls` для кожного маркера
2. Зберігається `barcodeValue` - унікальний ID маркера (наприклад, 1, 2, 3)
3. Маркер реєструється в AR-контексті через `context.addMarker(this)`
4. Викликається `_initArtoolkit()` для налаштування розпізнавання

---

### 2.3. Етап 3: Реєстрація маркера в AR.js

**Важливе уточнення:** Попри те, що POSIT алгоритм згадується у багатьох джерелах про AR, ARToolKit використовує **інший метод для планарних маркерів**:

- **POSIT** вимагає 4 НЕ-копланарних точки (не лежать в одній площині)
- **Квадратні маркери** мають 4 точки в одній площині (Z=0)
- Тому ARToolKit використовує **обчислення гомографії з подальшим розкладанням на R та t** (див. розділ 2.0 вище)

---

**Файл:** `threex-armarkercontrols.js` (метод `_initArtoolkit`)

```javascript
ARjs.MarkerControls.prototype._initArtoolkit = function() {
    var _this = this;
    
    // Чекаємо ініціалізації arController
    var delayedInitTimerId = setInterval(function() {
        var arController = _this.context.arController;
        if (arController === null) return;
        
        clearInterval(delayedInitTimerId);
        postInit();
    }, 1000/50);
    
    function postInit() {
        var arController = _this.context.arController;
        
        // Реєструємо barcode-маркер для відстеження
        if (_this.parameters.type === 'barcode') {
            artoolkitMarkerId = _this.parameters.barcodeValue;
            arController.trackBarcodeMarkerId(artoolkitMarkerId, _this.parameters.size);
        }
        
        // Слухаємо події виявлення маркерів
        arController.addEventListener('getMarker', function(event) {
            if (event.data.type === artoolkit.BARCODE_MARKER && 
                _this.parameters.type === 'barcode') {
                
                if (event.data.marker.idMatrix === artoolkitMarkerId) {
                    onMarkerFound(event);
                }
            }
        });
    }
    
    function onMarkerFound(event) {
        // Перевірка мінімальної впевненості
        if (event.data.marker.cfMatt < _this.parameters.minConfidence) {
            return;
        }
        
        // Отримуємо матрицю трансформації
        // event.data.matrix містить 16 елементів (матриця 4x4 у форматі Float32Array)
        // Матриця вже містить позицію (X, Y, Z) та обертання маркера відносно камери
        var modelViewMatrix = new THREE.Matrix4().fromArray(event.data.matrix);
        
        // Оновлюємо позицію 3D-об'єкта
        _this.updateWithModelViewMatrix(modelViewMatrix);
    }
};
```

**Що відбувається:**
1. Після ініціалізації `arController`, викликається `trackBarcodeMarkerId()`
2. Ця функція реєструє маркер з вказаним ID у системі відстеження AR.js
3. Встановлюється слухач подій `getMarker`, який реагує на виявлення маркерів
4. Коли знайдено маркер зі співпадаючим `idMatrix`, викликається `onMarkerFound()`
5. Перевіряється впевненість розпізнавання (`cfMatt` - confidence matrix)
6. **Отримується матриця трансформації (`modelViewMatrix`) з даних маркера:**
   - Детальне пояснення обчислення матриці див. у розділі **2.0. Етап 0: Математичні основи**
   - Матриця 4x4 (16 елементів) кодує позицію та обертання маркера
   - **Позиція:** індекси 12 (X), 13 (Y), 14 (Z) у масиві Float32Array
   - **Обертання:** індекси 0-11 (матриця 3x3)
   - Матриця передається через `event.data.matrix` і конвертується у Three.js формат

---

### 2.4. Етап 4: Обробка кадрів та детектування

**Файл:** `threex-artoolkitcontext.js` (метод `update`)

```javascript
ARjs.Context.prototype.update = function(srcElement) {
    // Перевірка максимальної частоти детектування
    var present = performance.now();
    if (this._updatedAt !== null && 
        present - this._updatedAt < 1000/this.parameters.maxDetectionRate) {
        return false;
    }
    this._updatedAt = present;
    
    // Ховаємо всі маркери перед обробкою кадру
    this._arMarkersControls.forEach(function(markerControls) {
        markerControls.object3d.visible = false;
    });
    
    // Обробка кадру для artoolkit
    if (this.parameters.trackingBackend === 'artoolkit') {
        this._updateArtoolkit(srcElement);
    }
    
    return true;
};

ARjs.Context.prototype._updateArtoolkit = function(srcElement) {
    // Передаємо кадр з камери до AR.js для обробки
    this.arController.process(srcElement);
};
```

**Файл:** `js/ar.js` (метод `ARController.prototype.process`)

```javascript
ARController.prototype.process = function(image) {
    // Детектуємо маркери на зображенні
    this.detectMarker(image);
    
    // Отримуємо кількість знайдених маркерів
    var markerNum = this.getMarkerNum();
    
    for (var i = 0; i < markerNum; i++) {
        var markerInfo = this.getMarker(i);
        var markerType = artoolkit.UNKNOWN_MARKER;
        
        // Перевіряємо тип маркера
        if (markerInfo.idMatrix > -1) {
            // Це barcode-маркер
            visible = this.trackBarcodeMarkerId(markerInfo.idMatrix);
            markerType = artoolkit.BARCODE_MARKER;
        }
        
        if (markerType !== artoolkit.UNKNOWN_MARKER && visible.inPrevious) {
            // Маркер був видимий у попередньому кадрі - використовуємо гладку трансформацію
            this.getTransMatSquareCont(i, visible.markerWidth, visible.matrix, visible.matrix);
        } else {
            // Новий маркер - обчислюємо трансформацію з нуля
            this.getTransMatSquare(i, visible.markerWidth, visible.matrix);
        }
        
        visible.inCurrent = true;
        
        // Конвертуємо матрицю у формат Three.js
        this.transMatToGLMat(visible.matrix, this.transform_mat);
        
        // Генеруємо подію для слухачів
        this.dispatchEvent({
            name: "getMarker",
            target: this,
            data: {
                index: i,
                type: markerType,
                marker: markerInfo,
                matrix: this.transform_mat
            }
        });
    }
};
```

**Що відбувається:**
1. На кожен кадр викликається `detectMarker()` - пошук маркерів на зображенні
2. Отримуємо кількість знайдених маркерів через `getMarkerNum()`
3. Для кожного маркера:
   - Визначається тип (`BARCODE_MARKER` якщо `idMatrix > -1`)
   - **Якщо маркер був видимий у попередньому кадрі (`inPrevious`), використовується гладка трансформація (`getTransMatSquareCont`):**
     - **`inPrevious = true`** означає, що маркер було виявлено в попередньому кадрі (60 FPS)
     - **`getTransMatSquareCont()`** (Continuous) використовує попередню матрицю трансформації як початкове наближення
     - **Переваги:**
       - Швидша збіжність (менше ітерацій POSIT)
       - Менше "стрибків" позиції між кадрами
       - Плавніше відстеження при русі камери
       - Краща стійкість до тимчасових перешкод (розмиття, часткове перекриття)
     - **Як працює:**
       1. Бере матрицю з попереднього кадру (`visible.matrix`)
       2. Використовує її як початкове наближення для POSIT
       3. Виконує 1-2 ітерації для уточнення (замість 4-8 з нуля)
       4. Результат — плавна зміна позиції між кадрами
   - **Якщо маркер новий або щойно з'явився (`inPrevious = false`):**
     - **`getTransMatSquare()`** обчислює трансформацію з повного нуля
     - Потребує більше ітерацій (4-8) для збіжності
     - Може бути менш стабільним у перших кадрах
   - Матриця трансформації конвертується у формат Three.js (`transMatToGLMat`)
   - Генерується подія `getMarker` з даними про маркер

**Приклад: Різниця між getTransMatSquare та getTransMatSquareCont:**

```
КАДР 1 (маркер щойно з'явився, inPrevious = false):
┌────────────────────────────────────────┐
│ getTransMatSquare() - з нуля           │
│ Ітерацій: 6                            │
│ Результат: X=0.12, Y=0.05, Z=0.45     │
│ Стабільність: середня (може "стрибати")│
└────────────────────────────────────────┘

КАДР 2-60 (маркер відстежується, inPrevious = true):
┌────────────────────────────────────────┐
│ getTransMatSquareCont() - продовження  │
│ Ітерацій: 2                            │
│ Результат: X=0.12, Y=0.05, Z=0.45     │
│ Стабільність: висока (плавна зміна)    │
└────────────────────────────────────────┘

КАДР 61 (маркер зник і з'явився знову):
┌────────────────────────────────────────┐
│ getTransMatSquare() - знову з нуля     │
│ Ітерацій: 7                            │
│ Результат: X=0.12, Y=0.05, Z=0.45     │
│ Стабільність: середня                 │
└────────────────────────────────────────┘
```

---

### 2.5. Етап 5: Оновлення позиції 3D-об'єкта

**Файл:** `threex-armarkercontrols.js` (метод `updateWithModelViewMatrix`)

```javascript
ARjs.MarkerControls.prototype.updateWithModelViewMatrix = function(modelViewMatrix) {
    var markerObject3D = this.object3d;
    
    // Робимо об'єкт видимим
    markerObject3D.visible = true;
    
    // Застосовуємо трансформацію осей для artoolkit
    if (this.context.parameters.trackingBackend === 'artoolkit') {
        var tmpMatrix = new THREE.Matrix4().copy(
            this.context._artoolkitProjectionAxisTransformMatrix
        );
        tmpMatrix.multiply(modelViewMatrix);
        modelViewMatrix.copy(tmpMatrix);
    }
    
    // Копіюємо матрицю в об'єкт Three.js
    if (this.parameters.changeMatrixMode === 'modelViewMatrix') {
        markerObject3D.matrix.copy(modelViewMatrix);
    }
    
    // Декомпозиція матриці на позицію, обертання, масштаб
    markerObject3D.matrix.decompose(
        markerObject3D.position,
        markerObject3D.quaternion,
        markerObject3D.scale
    );
    
    // Генеруємо подію
    this.dispatchEvent({ type: 'markerFound' });
};
```

**Що відбувається:**
1. **Отримана матриця трансформації перетворюється з системи координат AR.js у систему Three.js:**
   - **Проблема:** AR.js (ARToolKit) і Three.js використовують різні системи координат
   - **AR.js система координат:**
     ```
          Y ↑
          │
          │   Z → (вперед, перпендикулярно до маркера)
          │  ╱
          │ ╱
          └────→ X
         (вправо)

     - Y вісь: вгору (вздовж лівого краю маркера, у площині маркера)
       * Це означає, що Y-вісь лежить у площині маркера
       * Y-вісь проходить вздовж лівого краю маркера (від низу до верху)
       * Додатні значення Y — вище центру маркера (до верхнього краю)
       * Від'ємні значення Y — нижче центру маркера (до нижнього краю)
       * Приклад: конус висотою 1 одиниця матиме вершину в Y = 1.0 (на 1 одиницю вище поверхні маркера)
     - X вісь: вправо (вздовж нижнього краю маркера, у площині маркера)
       * X-вісь проходить вздовж нижнього краю маркера (від лівого до правого)
       * Додатні значення X — праворуч від центру маркера
       * Від'ємні значення X — ліворуч від центру маркера
     - Z вісь: вперед (перпендикулярно до площини маркера)
       * Це означає, що Z-вісь спрямована "від" маркера у простір
       * Z-вісь перпендикулярна до поверхні маркера
       * Коли ви дивитесь на маркер прямо, Z-вісь "дивиться" на вас
       * Відстань по Z збільшується, коли камера віддаляється від маркера
       * У прикладі вище: Z = 50 см означає, що камера знаходиться за 50 см від маркера

     **Важливо:** У AR.js початок координат (0, 0, 0) знаходиться у центрі маркера на його поверхні.
     Всі позиції 3D-об'єктів обчислюються відносно цього центру.

     **Приклад орієнтації маркера:**
     ```
     Якщо маркер лежить на столі перед вами:

           Y (вгору, до стелі)
           ↑
           │
           │
           │
     (ліво) └────→ X (вправо, вздовж нижнього краю)
          ╱
         ╱
        Z → (до вас, перпендикулярно до поверхні столу)

     Початок координат (0, 0, 0) — у центрі маркера на поверхні столу
     ```
     ```
   
   - **Three.js система координат:**
     ```
         Y ↑
         │
         │
         │
         └────→ X
        ╱    (вправо)
       ╱
      Z → (назустріч камері / з екрану)
     
     - Y вісь: вгору (вертикаль)
     - X вісь: вправо (горизонталь)
     - Z вісь: назустріч камері (глибина)
     ```
   
   - **Трансформація між системами:**
     - **Проблема:** AR.js і Three.js використовують різні системи координат
     - **AR.js система:** Y і X лежать у площині маркера, Z спрямована до камери
     - **Three.js система:** Y спрямована вгору (до стелі), Z — до глядача (горизонтально)
     - **Рішення:** Потрібно повернути систему координат на 180° навколо осі Y та 180° навколо осі Z
     - Це виконується через `_artoolkitProjectionAxisTransformMatrix`
     - Матриця трансформації визначена в `threex-artoolkitcontext.js`:
       ```javascript
       this._artoolkitProjectionAxisTransformMatrix = new THREE.Matrix4()
       this._artoolkitProjectionAxisTransformMatrix.multiply(
           new THREE.Matrix4().makeRotationY(Math.PI)
       )
       this._artoolkitProjectionAxisTransformMatrix.multiply(
           new THREE.Matrix4().makeRotationZ(Math.PI)
       )
       ```

   - **Чому потрібна трансформація?**
     ```
     Коли маркер лежить на столі:

     AR.js (відносно маркера):     Three.js (відносно світу):
     
          Y ↑ (вздовж маркера)         Y ↑ (до стелі)
          │                            │
          │   Z → (до камери)          │
          │  ╱                         └────→ X (вправо)
          │ ╱                         ╱
          └────→ X (вздовж маркера)   ╱
                                     Z → (до глядача)
     
     Без трансформації:
     - AR.js каже: "Y = 1" (вздовж маркера у площині столу)
     - Three.js розуміє: "Y = 1" (вгору до стелі)
     - Результат: 3D-об'єкт з'являється НЕ там, де має бути!
     
     З трансформацією:
     - AR.js: Y = 1 (вздовж маркера) → Three.js: Y = 1 (вгору до стелі) ✓
     - AR.js: Z = 50 (до камери) → Three.js: Z = -50 (від глядача) ✓
     - Результат: 3D-об'єкт правильно розміщується НАД маркером
     ```

   - **Візуальний приклад:**
     ```
     Без трансформації:          З трансформацією:

          КАМЕРА                     КАМЕРА
            ↓                          ↓
            │                          │
            │                          │
         ┌──┴──┐                    ┌──┴──┐
         │ 🟦  │ ← 3D об'єкт          │     │
         │ МАР │   (під маркером!)   │ 🟦  │ ← 3D об'єкт
         └─────┘   ❌                │ МАР │   (над маркером!)
                                    └─────┘   ✓
     ```

   - **Приклад перетворення (матриця з розділу 2.0.4):**
     ```
     AR.js матриця (до перетворення):
     ┌                                              ┐
     │  1.00   0.00   0.00   0.12  │  X = 12 см
     │  0.00   1.00   0.00   0.05  │  Y = 5 см (вгору від маркера)
     │  0.00   0.00   1.00   0.45  │  Z = 45 см (вперед від маркера)
     │  0.00   0.00   0.00   1.00  │
     └                                              ┘

     Після множення на _artoolkitProjectionAxisTransformMatrix:
     ┌                                              ┐
     │  1.00   0.00   0.00   0.12  │  X = 12 см (те саме)
     │  0.00  -1.00   0.00  -0.05  │  Y = -5 см (інвертовано)
     │  0.00   0.00  -1.00  -0.45  │  Z = -45 см (інвертовано)
     │  0.00   0.00   0.00   1.00  │
     └                                              ┘

     Результат: 3D-об'єкт правильно орієнтований у сцені Three.js
     ```

2. Матриця копіюється в `object3d.matrix`

3. Виконується декомпозиція матриці на:
   - `position` - позиція (x, y, z)
   - `quaternion` - обертання (кватерніон)
   - `scale` - масштаб

4. 3D-об'єкт стає видимим і позиціонується відповідно до маркера

---

### 2.6. Етап 6: Візуалізація 3D-примітива (конус)

**Файл:** `index.html` (створення контенту для маркера)

```javascript
case 'primitive':
    if (config.markers[i] && config.markers[i].primitive) {
        const primitive = config.markers[i].primitive;
        let geometry, material, mesh;
        
        // Створення геометрії конуса
        if (primitive.type === 'ConeGeometry') {
            var coneHeight = primitive.height || 1;
            geometry = new THREE.ConeGeometry(
                primitive.radius || 0.5,
                coneHeight,
                primitive.radialSegments || 32
            );
            
            // Зміщуємо геометрію, щоб основа була в центрі координат
            geometry.translate(0, coneHeight / 2, 0);
        }
        
        // Створення матеріалу
        if (primitive.textureFile) {
            let texture = new THREE.TextureLoader().load(primitive.textureFile);
            material = new THREE.MeshBasicMaterial({
                map: texture,
                color: new THREE.Color(primitive.color || '#ffffff')
            });
        } else {
            material = new THREE.MeshBasicMaterial({
                color: new THREE.Color(primitive.color || '#ffffff')
            });
        }
        
        // Створення мешу
        mesh = new THREE.Mesh(geometry, material);
        
        // Застосування позиції та обертання
        if (primitive.position) {
            mesh.position.set(...primitive.position);
        }
        if (primitive.rotation) {
            mesh.rotation.set(...primitive.rotation);
        }
        
        // Додавання до контейнера маркера
        markerRoots[i].add(mesh);
        
        // Збереження для анімації
        if (primitive.animation) {
            mesh.userData.animation = primitive.animation;
        }
    }
    break;
```

**Що відбувається:**
1. Створюється геометрія конуса (`ConeGeometry`) з вказаними параметрами
2. Геометрія зміщується так, щоб основа конуса була в центрі координат маркера
3. Створюється матеріал (з кольором або текстурою)
4. Створюється 3D-меш (геометрія + матеріал)
5. Меш додається до контейнера маркера (`markerRoots[i]`)
6. Коли маркер виявляється, контейнер позиціонується відповідно до матриці трансформації

---

## 3. Повний цикл обробки даних

### 3.1. Діаграма потоку даних

```
┌─────────────────────────────────────────────────────────────────┐
│                        КАМЕРА (веб-камера)                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  ARToolkitSource (threex-artoolkitsource.js)                    │
│  - Отримує відеопотік з камери                                   │
│  - Надає кадри для обробки                                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  ARToolkitContext.update() (threex-artoolkitcontext.js)         │
│  - Перевіряє частоту кадрів                                      │
│  - Ховає всі маркери перед обробкою                              │
│  - Викликає arController.process()                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  ARController.process() (js/ar.js - AR.js)                      │
│  - detectMarker() - пошук маркерів на зображенні                │
│  - getMarkerNum() - кількість знайдених маркерів                │
│  - Для кожного маркера:                                          │
│    • Визначення типу (barcode/pattern)                           │
│    • Обчислення матриці трансформації                            │
│    • Генерація події 'getMarker'                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Слухач подій (threex-armarkercontrols.js)                      │
│  - Перевіряє тип маркера та ID                                   │
│  - Перевіряє впевненість розпізнавання                           │
│  - Викликає onMarkerFound(event)                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  updateWithModelViewMatrix() (threex-armarkercontrols.js)       │
│  - Перетворює матрицю з AR.js у формат Three.js                 │
│  - Декомпозиція матриці (position, quaternion, scale)           │
│  - Оновлення позиції 3D-об'єкта                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  markerRoots[i] (Three.js Group)                                │
│  - Містить 3D-об'єкти (конус, модель, зображення тощо)          │
│  - Позиціонується відповідно до маркера                          │
│  - Робиться видимим при виявленні маркера                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  renderer.render() (Three.js)                                   │
│  - Візуалізує сцену з 3D-об'єктами                               │
│  - Відображає на екрані                                          │
└─────────────────────────────────────────────────────────────────┘
```

---

### 3.2. Послідовність подій у часі

| Час | Подія |
|-----|-------|
| T0 | Ініціалізація AR-контексту та камери |
| T1 | Створення контролерів для кожного barcode-маркера |
| T2 | Реєстрація маркерів у AR.js (`trackBarcodeMarkerId`) |
| T3 | Отримання відеопотоку з камери |
| T4 | **Цикл обробки кадрів (60 FPS):** |
| T4.1 | - ARToolkitContext.update() викликається на кожен кадр |
| T4.2 | - arController.process() обробляє зображення |
| T4.3 | - detectMarker() шукає маркери |
| T4.4 | - Для знайдених маркерів обчислюється матриця трансформації |
| T4.5 | - Генерується подія `getMarker` |
| T4.6 | - Слухач подій перевіряє ID маркера |
| T4.7 | - updateWithModelViewMatrix() оновлює позицію 3D-об'єкта |
| T4.8 | - renderer.render() візуалізує сцену |
| T5 | Анімація об'єктів (якщо вказана в конфігурації) |

---

## 4. Приклад: Конус на barcode-маркері

### 4.1. Конфігурація (config.json)

```json
{
  "markers": [
    {
      "type": "barcode",
      "target": 1,
      "contentType": "primitive",
      "primitive": {
        "type": "ConeGeometry",
        "radius": 0.5,
        "height": 1,
        "color": "#ff0000",
        "animation": {
          "axis": "y",
          "speed": 0.01
        }
      }
    }
  ]
}
```

### 4.2. Що відбувається при виявленні маркера з ID=1

1. **Камера** захоплює зображення з barcode-маркером
2. **AR.js** розпізнає маркер з `idMatrix = 1`
3. **Слухач подій** перевіряє: `event.data.marker.idMatrix === 1` ✓
4. **Обчислюється** матриця трансформації (позиція + обертання маркера)
5. **Оновлюється** позиція `markerRoots[0]` (група для маркера 1)
6. **Візуалізується** конус у позиції маркера
7. **Анімується** обертання конуса навколо осі Y (з конфігурації)

---

## 5. Ключові відмінності barcode від pattern-маркерів

| Характеристика | Barcode-маркер | Pattern-маркер |
|----------------|----------------|----------------|
| **Тип розпізнавання** | Матричний код (3x3, 4x4) | Зображення-шаблон (.patt файл) |
| **Ідентифікація** | За числовим ID (`idMatrix`) | За завантаженим шаблоном (`idPatt`) |
| **Реєстрація** | `trackBarcodeMarkerId(id, size)` | `loadMarker(url, callback)` + `trackPatternMarkerId(id, size)` |
| **Подія** | `event.data.marker.idMatrix` | `event.data.marker.idPatt` |
| **Впевненість** | `event.data.marker.cfMatt` | `event.data.marker.cfPatt` |
| **Гнучкість** | Висока (будь-яке числове ID) | Низька (потрібен .patt файл для кожного) |

---

## 6. Висновки

### 6.1. Переваги barcode-маркерів у AR.js

1. **Простота використання** - не потрібні окремі файли шаблонів
2. **Гнучкість** - можна використовувати будь-які числові ID
3. **Швидкість** - матричне розпізнавання швидше за шаблонне
4. **Надійність** - краще розпізнавання під різними кутами

### 6.2. Недоліки

1. **Обмежена кількість** - залежить від типу матриці (3x3 = 512 маркерів)
2. **Менш унікальні** - можуть плутатися схожі матриці
3. **Залежність від друку** - якість друку впливає на розпізнавання

### 6.3. Чому додано ArUco-маркери

Aruco-маркери (реалізовані у `js-aruco2/`) пропонують:
- Більшу кількість унікальних маркерів
- Кращу стійкість до спотворень
- Можливість створення маркерів "від руки"
- Сучасніші алгоритми розпізнавання

Але вони **не інтегровані** з AR.js, тому використовують окремий контекст обробки.

---

## 7. Глосарій термінів

| Термін | Визначення |
|--------|------------|
| **AR.js** | Бібліотека для доповненої реальності у вебі, заснована на ARToolKit |
| **ARToolKit** | Бібліотека для розпізнавання маркерів та відстеження позиції |
| **Barcode-маркер** | Матричний код (наприклад, 3x3), що ідентифікується за числовим ID |
| **Pattern-маркер** | Маркер-шаблон, що розпізнається за зображенням (.patt файл) |
| **ModelViewMatrix** | Матриця 4x4, що описує позицію та обертання об'єкта у 3D-просторі |
| **Three.js** | Бібліотека для 3D-графіки у вебі |
| **THREEx** | Розширення для Three.js, що інтегрує AR.js |

---

## Додаток A: Посилання на файли

- **Головний файл:** `index.html`
- **AR.js бібліотека:** `js/ar.js` (artoolkit)
- **AR-контекст:** `threex/threex-artoolkitcontext.js`
- **Контролери маркерів:** `threex/threex-armarkercontrols.js`
- **Джерело відео:** `threex/threex-artoolkitsource.js`
- **Aruco (альтернатива):** `js-aruco2/`, `js/aruco.js`

---

*Документ створено на основі аналізу коду WebAR-проекту.*
