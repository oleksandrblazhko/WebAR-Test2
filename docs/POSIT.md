
POSIT (Pose from Orthography and Scaling with Iterations) — це алгоритм оцінювання пози та орієнтації об’єкта (6DoF) відносно камери на основі відповідностей між 3D-точками об’єкта та їхніми 2D-проєкціями на зображенні. Алгоритм належить до класу задач Perspective-n-Point (PnP).

Алгоритм був запропонований дослідниками Didier DeMenthon та Larry S. Davis у 1995 році.

Ідея алгоритму
У задачі PnP задано:

набір 3D-точок об’єкта 
P
i
=
(
X
i
,
Y
i
,
Z
i
)
P 
i
​
 =(X 
i
​
 ,Y 
i
​
 ,Z 
i
​
 );

їх координати на зображенні 
p
i
=
(
x
i
,
y
i
)
p 
i
​
 =(x 
i
​
 ,y 
i
​
 );

параметри камери (фокусна відстань тощо).

Потрібно знайти:

матрицю обертання 
R
R;

вектор перенесення 
t
t.

Основна ідея POSIT:

Перспективну проєкцію наближено замінюють масштабованою ортографічною проєкцією.

На основі цього наближення швидко обчислюється початкова оцінка пози.

Далі виконується ітераційне уточнення, де:

оцінюється масштаб кожної точки;

перераховується положення об’єкта;

процедура повторюється до збіжності.

Чому працює наближення
Для багатьох практичних сцен:

об’єкт невеликий порівняно з відстанню до камери;

перспектива не дуже сильна.

У цьому випадку перспективну модель можна представити як:

x
≈
f
Z
0
X
,
y
≈
f
Z
0
Y
x≈ 
Z 
0
​
 
f
​
 X,y≈ 
Z 
0
​
 
f
​
 Y
де 
Z
0
Z 
0
​
  — середня глибина точок.

Це і є ортографічне наближення з масштабом.

Алгоритм POSIT (спрощена схема)
Обрати опорну точку.

Побудувати систему рівнянь для ортографічної моделі.

Обчислити:

перше наближення 
R
,
t
R,t.

Для кожної ітерації:

оцінити глибину точок;

уточнити масштаб;

заново обчислити 
R
,
t
R,t.

Зупинка при малих змінах параметрів.

Властивості
Переваги

дуже швидкий;

стабільний для невеликої кількості точок (4–20);

добре працює для AR-задач.

Недоліки

чутливий до шуму;

погіршується при сильній перспективі;

потребує хороших відповідностей точок.

POSIT у комп’ютерному зорі та AR
Алгоритм активно використовується у:

маркерному AR (ArUco, AprilTag);

трекінгу об’єктів;

робототехніці.

У бібліотеці OpenCV він історично реалізовувався як один із варіантів розв’язання задачі PnP (нині частіше застосовують сучасніші методи — EPnP, ITERATIVE, RANSAC-PnP).

Зв’язок із задачею Perspective-n-Point
Загальна задача:

PnP: 
(
P
i
3
D
,
p
i
2
D
)
→
(
R
,
t
)
PnP: (P 
i
3D
​
 ,p 
i
2D
​
 )→(R,t)
POSIT — це:

один із класичних алгоритмів PnP;

орієнтований на швидке ітераційне уточнення через ортографічне наближення.

Якщо потрібно, можу:

показати математичне виведення POSIT;

порівняти POSIT vs EPnP vs ITERATIVE;

пояснити, як саме POSIT використовується у ArUco-детекції (у контексті вашого WebAR-коду).


You said:
пояснити, як саме POSIT використовується у ArUco-детекції

ChatGPT said:
У маркерній доповненій реальності (AR) алгоритм POSIT використовується як один із способів розв’язання задачі оцінювання пози (pose estimation) після того, як маркер уже знайдено на зображенні. Найчастіше це відбувається всередині бібліотек типу OpenCV або реалізацій ArUco.

Нижче — повний ланцюжок обробки.

Загальний pipeline ArUco-детекції
1. Захоплення кадру
Камера дає зображення:

I
(
x
,
y
)
I(x,y)
2. Пошук квадратних контурів
Алгоритм:

знаходить контури;

відбирає ті, що схожі на квадрат;

перевіряє внутрішній бінарний код.

На цьому етапі визначається:

ID маркера;

координати його 4 кутів у пікселях:

p
i
=
(
x
i
,
y
i
)
,
i
=
1..4
p 
i
​
 =(x 
i
​
 ,y 
i
​
 ),i=1..4
3. Відомі 3D-координати кутів маркера
Оскільки маркер — це квадрат із відомим розміром 
L
L, його координати задаються в системі маркера:

P
1
=
(
−
L
/
2
,
−
L
/
2
,
0
)
P 
1
​
 =(−L/2,−L/2,0)
P
2
=
(
L
/
2
,
−
L
/
2
,
0
)
P 
2
​
 =(L/2,−L/2,0)
P
3
=
(
L
/
2
,
L
/
2
,
0
)
P 
3
​
 =(L/2,L/2,0)
P
4
=
(
−
L
/
2
,
L
/
2
,
0
)
P 
4
​
 =(−L/2,L/2,0)
Тобто задача стає класичною:

4 відповідності 3D → 2D

Де з’являється POSIT
Тепер потрібно знайти:

обертання 
R
R

перенесення 
t
t

тобто:

P
3
D
→
p
2
D
P 
3D
​
 →p 
2D
​
 
Це задача Perspective-n-Point.

Саме тут застосовується POSIT.

Як працює POSIT у випадку ArUco
Оскільки:

маркер маленький;

всі точки лежать у площині;

кількість точок мінімальна (4),

алгоритм працює дуже швидко.

Кроки:
Беруться:

4 точки маркера у 3D;

їх проєкції на зображенні;

матриця камери 
K
K.

POSIT:

будує початкову оцінку пози через scaled orthographic approximation;

оцінює глибину точок;

уточнює обертання;

повторює кілька ітерацій.

Отримується:

R
,
t
R,t
Що означає результат для AR
Матриця пози:

T
=
[
R
t
0
1
]
T=[ 
R
0
​
  
t
1
​
 ]
дозволяє:

поставити 3D-об’єкт поверх маркера;

синхронізувати рух камери;

обертати сцену.

У вашому випадку (Three.js + WebAR):

ця матриця передається в сцену;

конус «приклеюється» до маркера.

Реальна реалізація (як це виглядає в коді)
У OpenCV pipeline виглядає так:

detectMarkers(...)
estimatePoseSingleMarkers(...)
Функція estimatePoseSingleMarkers() всередині викликає:

solvePnP(...)
А solvePnP() може використовувати:

POSIT (класичний варіант);

ITERATIVE (Levenberg–Marquardt);

EPnP (сучасний стандарт).

Важлива деталь (часто неочевидна)
У сучасних версіях OpenCV:

POSIT майже не використовується напряму;

частіше застосовується:

EPnP

SOLVEPNP_ITERATIVE

Але концептуально:

вся маркерна AR досі повторює логіку POSIT
(швидка початкова оцінка + уточнення).

Чому ArUco добре підходить для POSIT
Тому що маркер:

має чіткі кути;

має відомі розміри;

є жорстким об’єктом.

Це ідеальний випадок для PnP.

Візуальна схема процесу
Camera frame
   ↓
Contours
   ↓
ArUco ID detection
   ↓
4 corners (2D)
   +
Known square (3D)
   ↓
PnP (POSIT / EPnP)
   ↓
R, t
   ↓
3D rendering (Three.js)
Як це пов’язано з вашим AR-кодом
У вашому прикладі з:

ArUco

Three.js

WebAR

алгоритм працює так:

JS-бібліотека знаходить кути маркера.

Виконується PnP (часто через JS-реалізацію POSIT).

Обчислюється pose.

Three.js застосовує matrix transform.

Саме тому конус:

рухається разом із маркером;

зберігає перспективу.

Якщо хочете, можу показати:

математичний розбір solvePnP саме для квадратного маркера (там є цікаве спрощення);

або пояснити, чому плоскі маркери іноді “перевертаються” (ефект pose ambiguity — дуже важливо для WebAR).


You said:
пояснити, чому плоскі маркери іноді “перевертаються” (ефект pose ambiguity — дуже важливо для WebAR).

ChatGPT said:
Ефект, коли плоский маркер “перевертається” (об’єкт раптом повертається на 180° або «стрибає» між двома положеннями), називається pose ambiguity. Це фундаментальна геометрична проблема задачі PnP для планарних (плоских) об’єктів, і вона часто проявляється у WebAR при використанні маркерів ArUco або функцій з OpenCV.

Суть проблеми
Коли всі точки лежать в одній площині (як у квадратного маркера), одна і та сама 2D-проєкція може відповідати двом різним 3D-положенням об’єкта.

Інакше кажучи:

(
P
3
D
→
p
2
D
)
(P 
3D
​
 →p 
2D
​
 )
для планарного випадку має два розв’язки:

правильний;

«дзеркальний» (перевернутий відносно площини камери).

Алгоритм PnP (у тому числі POSIT або інші) іноді обирає не той розв’язок — або починає перемикатися між ними через шум.

Геометрична причина
Для плоского об’єкта проєкція описується гомографією:

p
∼
H
P
p∼HP
Гомографія не містить достатньої інформації, щоб однозначно відновити знак глибини для всіх точок.

У результаті виникають два можливі положення:

      Камера
         |
         |
     (варіант 1)
        / \
       /   \
------Маркер------

     (варіант 2)
       \   /
        \ /
------Маркер------
Обидва положення дають дуже схожу проєкцію.

Коли це проявляється найчастіше
1. Малий нахил маркера
Якщо площина майже фронтальна до камери, різниця між двома розв’язками мінімальна.

2. Шум у координатах кутів
Навіть 1–2 пікселі можуть перемкнути рішення.

3. Низька роздільна здатність
Кути визначаються неточно.

4. Малий розмір маркера в кадрі
Геометрична стабільність різко падає.

Як виглядає ефект у AR
Типові симптоми:

3D-об’єкт раптом перевертається;

з’являється «дрижання» (jitter);

rotation змінюється на ~180°;

об’єкт «провалюється» під маркер.

У Three.js це виглядає як різкий стрибок матриці.

Чому це фундаментальна проблема
Якщо всі точки лежать у площині:

Z
i
=
0
Z 
i
​
 =0
то інформації про глибину недостатньо.

Це не помилка алгоритму — це геометрична неоднозначність.

Основні способи боротьби
1. Використання solvePnP з перевіркою розв’язків
У OpenCV є методи:

SOLVEPNP_ITERATIVE

SOLVEPNP_IPPE (спеціально для площин)

IPPE обчислює обидва розв’язки і вибирає стабільніший.

2. Temporal filtering (найефективніше для WebAR)
Ідея:

порівнювати позу з попереднім кадром;

обирати розв’язок, ближчий до попереднього.

Це прибирає більшість «переворотів».

3. Збільшити розмір маркера
Чим більший маркер у кадрі:

тим точніше кути;

тим менше ambiguity.

4. Додати непланарні точки (найнадійніше)
Наприклад:

куб замість плоского маркера;

multi-marker board.

Тоді:

Z
i
≠
0
Z 
i
​
 

=0
і двозначність зникає.

5. Використовувати ArUco Board замість одного маркера
Кілька маркерів:

стабілізують pose;

зменшують шум.

Практично для WebAR (ключовий момент)
У більшості JS-бібліотек:

використовується спрощений PnP;

без фільтрації;

без перевірки другого розв’язку.

Тому «перевертання» — дуже поширене.

Найпростіше рішення:

згладжувати rotation через попередній кадр;

або застосувати exponential smoothing.

Важливий висновок
Плоский маркер дає:

не одну, а дві можливі пози камери.

Алгоритм просто змушений вибирати між ними — і через шум іноді перемикається.

Саме тому:

у професійних AR-системах майже завжди використовують непланарні або багатомаркерні конфігурації.

Якщо хочете, можу:

показати математичний розбір IPPE (алгоритм, спеціально створений для площин);

або розібрати ваш WebAR-код, щоб показати, де саме виникає перемикання і як додати стабілізацію.


You said:
математичний розбір solvePnP саме для квадратного маркера

ChatGPT said:
Розглянемо математичний розбір задачі solvePnP саме для квадратного маркера, тобто найтиповіший випадок у маркерному AR (наприклад, у ArUco та OpenCV).

Цей випадок має важливу особливість:
усі точки лежать в одній площині, що дозволяє сильно спростити математику.

1. Постановка задачі
Є:

3D координати кутів маркера (у системі маркера)
Нехай сторона маркера 
L
L.

P
1
=
(
−
L
/
2
,
 
−
L
/
2
,
 
0
)
P 
1
​
 =(−L/2,−L/2,0)
P
2
=
(
L
/
2
,
 
−
L
/
2
,
 
0
)
P 
2
​
 =(L/2,−L/2,0)
P
3
=
(
L
/
2
,
 
L
/
2
,
 
0
)
P 
3
​
 =(L/2,L/2,0)
P
4
=
(
−
L
/
2
,
 
L
/
2
,
 
0
)
P 
4
​
 =(−L/2,L/2,0)
Важливо:

Z
i
=
0
Z 
i
​
 =0
тобто об’єкт планарний.

2D координати на зображенні
p
i
=
(
x
i
,
y
i
)
p 
i
​
 =(x 
i
​
 ,y 
i
​
 )
Камера
Відома матриця внутрішніх параметрів:

K
=
[
f
x
0
c
x
0
f
y
c
y
0
0
1
]
K= 
​
  
f 
x
​
 
0
0
​
  
0
f 
y
​
 
0
​
  
c 
x
​
 
c 
y
​
 
1
​
  
​
 
Потрібно знайти
обертання 
R
R

перенесення 
t
t

такі, що:

s
[
x
y
1
]
=
K
[
R
∣
t
]
[
X
Y
Z
1
]
s 
​
  
x
y
1
​
  
​
 =K[R∣t] 
​
  
X
Y
Z
1
​
  
​
 
2. Ключове спрощення (планарний випадок)
Оскільки:

Z
=
0
Z=0
маємо:

s
 
p
=
K
[
r
1
  
r
2
  
t
]
[
X
Y
1
]
sp=K[r 
1
​
 r 
2
​
 t] 
​
  
X
Y
1
​
  
​
 
тобто:

p
∼
H
P
p∼HP
де

H
=
K
[
r
1
  
r
2
  
t
]
H=K[r 
1
​
 r 
2
​
 t]
Це гомографія.

Отже:

задача PnP для площини → задача знаходження гомографії.

3. Обчислення гомографії
Гомографія:

H
=
[
h
1
h
2
h
3
h
4
h
5
h
6
h
7
h
8
h
9
]
H= 
​
  
h 
1
​
 
h 
4
​
 
h 
7
​
 
​
  
h 
2
​
 
h 
5
​
 
h 
8
​
 
​
  
h 
3
​
 
h 
6
​
 
h 
9
​
 
​
  
​
 
Для кожної точки:

x
=
h
1
X
+
h
2
Y
+
h
3
h
7
X
+
h
8
Y
+
h
9
x= 
h 
7
​
 X+h 
8
​
 Y+h 
9
​
 
h 
1
​
 X+h 
2
​
 Y+h 
3
​
 
​
 
y
=
h
4
X
+
h
5
Y
+
h
6
h
7
X
+
h
8
Y
+
h
9
y= 
h 
7
​
 X+h 
8
​
 Y+h 
9
​
 
h 
4
​
 X+h 
5
​
 Y+h 
6
​
 
​
 
4 точки → 8 рівнянь → достатньо для розв’язку.

Зазвичай використовується:

DLT (Direct Linear Transform).

4. Як із гомографії отримати R і t
Маємо:

H
=
K
[
r
1
  
r
2
  
t
]
H=K[r 
1
​
 r 
2
​
 t]
Домножимо:

K
−
1
H
=
[
r
1
  
r
2
  
t
]
K 
−1
 H=[r 
1
​
 r 
2
​
 t]
Позначимо:

B
=
K
−
1
H
B=K 
−1
 H
Тоді:

B
=
[
b
1
  
b
2
  
b
3
]
B=[b 
1
​
 b 
2
​
 b 
3
​
 ]
де:

b
1
≈
r
1
b 
1
​
 ≈r 
1
​
 

b
2
≈
r
2
b 
2
​
 ≈r 
2
​
 

b
3
≈
t
b 
3
​
 ≈t

Нормалізація
Оскільки гомографія визначена з точністю до масштабу:

λ
=
1
∥
b
1
∥
λ= 
∥b 
1
​
 ∥
1
​
 
тоді:

r
1
=
λ
b
1
r 
1
​
 =λb 
1
​
 
r
2
=
λ
b
2
r 
2
​
 =λb 
2
​
 
t
=
λ
b
3
t=λb 
3
​
 
Обчислення третьої осі
r
3
=
r
1
×
r
2
r 
3
​
 =r 
1
​
 ×r 
2
​
 
Ортонормалізація
Через шум:

R
=
[
r
1
r
2
r
3
]
R=[ 
r 
1
​
 
​
  
r 
2
​
 
​
  
r 
3
​
 
​
 ]
може не бути ортонормальною.

Тому застосовується SVD:

R
=
U
V
T
R=UV 
T
 
5. Чому виникає pose ambiguity
Гомографія дає:

[
r
1
  
r
2
  
t
]
[r 
1
​
 r 
2
​
 t]
але знак масштабу невідомий.

Тому можливі:

t
або
−
t
tабо−t
Обидва дають схожу проєкцію.

Це і є причина «переворотів».

6. Чому квадрат — особливий випадок
Квадрат має:

симетрію;

рівні сторони;

ортогональні напрямки.

Це означає:

система дуже добре кондиційована;

достатньо лише 4 точок.

Саме тому квадратні маркери використовуються у AR.

7. Як це реалізовано в solvePnP
У випадку площини:

обчислюється гомографія;

із неї отримується початкова поза;

запускається ітераційне уточнення:

мінімізується reprojection error:

∑
i
∥
p
i
−
p
^
i
(
R
,
t
)
∥
2
i
∑
​
 ∥p 
i
​
 − 
p
^
​
  
i
​
 (R,t)∥ 
2
 
зазвичай методом:

Levenberg–Marquardt.

8. Спеціальний алгоритм для квадратів — IPPE
У сучасному AR частіше використовується метод:

Infinitesimal Plane-Based Pose Estimation (IPPE)

Він:

обчислює два розв’язки;

порівнює reprojection error;

вибирає правильний.

Саме тому він значно стабільніший для маркерів.

9. Повний pipeline для квадратного маркера
4 точки маркера
      ↓
Гомографія (DLT)
      ↓
K⁻¹H
      ↓
R, t (початкова оцінка)
      ↓
LM optimization
      ↓
Pose
Найважливіший концептуальний висновок
Для квадратного маркера:

solvePnP фактично зводиться до
розкладу гомографії.

Це ключовий факт, який часто не пояснюється в документації, але саме він визначає:

швидкість ArUco;

появу pose ambiguity;

нестабільність при малих кутах нахилу.

Якщо хочете, можу показати дуже корисну для WebAR річ:
як із цієї математики прямо випливає формула побудови матриці трансформації для Three.js (без solvePnP) — це дозволяє робити lightweight AR прямо у JavaScript без OpenCV.

1 message remaining. Upgrade to a Business plan to keep the conversation going

Get Business



