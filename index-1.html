<!DOCTYPE html>

<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>AR project template</title>
    <!-- Додаємо необхідні бібліотеки -->
    <script src="js/three.js"></script>
    <script src="js/tween.umd.js"></script>
    <script src='loaders/GLTFLoader.js'></script>
    <script src='loaders/GLTF2Loader.js'></script>
    <script src='loaders/MTLLoader.js'></script>
    <script src='loaders/OBJLoader.js'></script>
    <!-- Додаємо jsartookit -->
    <script src="jsartoolkit5/artoolkit.min.js"></script>
    <script src="jsartoolkit5/artoolkit.api.js"></script>
    <!-- Додаємо threex.artoolkit -->
    <script src="threex/threex-artoolkitsource.js"></script>
    <script src="threex/threex-artoolkitcontext.js"></script>
    <script src="threex/threex-arbasecontrols.js"></script>
    <script src="threex/threex-armarkercontrols.js"></script>

    <!-- Додаємо js-aruco2 -->
    <script type="text/javascript" src="js-aruco2/src/svd.js"></script>
    <script type="text/javascript" src="js-aruco2/src/posit1.js"></script>
    <script type="text/javascript" src="js-aruco2/src/cv.js"></script>
    <script type="text/javascript" src="js-aruco2/src/aruco.js"></script>
    <script type="text/javascript" src="js-aruco2/src/dictionaries/aruco_4x4_1000.js"></script>
    <script src="js/aruco.js"></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace; user-select: none; pointer-events: none;'>

    <div id="access" style="top: 0; left: 0; right:0; bottom: 0; background: #000; position: absolute; user-select: all; pointer-events: all;">
        <div id="text-wrapper" style="top: 50%; left: 50%; position: absolute; color: #fff; transform: translate(-50%, -50%); text-align: center;
                text-transform: uppercase; font-family: Arial, Helvetica, sans-serif; font-weight: 400; line-height: 1.5em; font-size: large; white-space: nowrap;
                user-select: none; pointer-events: none;
            ">
            Loading...
        </div>
    </div>

    <div id="loader" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #fff; pointer-events: none; user-select: none;
        transition: all .2s linear; display: none;">
        <div style="left: 50%; top: 50%; position: absolute; transform: translate(-50%, -50%); text-align: center; width: 130px; height: 165px;
            font-family: Arial, Helvetica, sans-serif; font-weight: 400; line-height: 1.5em; font-size: large;" class="spinner-wrapper">
            <img style="width: 130px; height: 130px; pointer-events: none; user-select: none;" src="data/spin.gif" alt="spin gif">
            <br>
            Loading...
        </div>
    </div>

    <script>
        const access = document.getElementById('access');
        const loader = document.getElementById('loader');

        // Оголошуємо глобальну змінну для конфігурації
        let config = null; // Configuration loaded from config.json

        // Змінні для діагностики Тесту 2
        let lastMarkerStates = {};
        let lastUpdateTime = 0;
        
        // Змінні для тактильного відгуку (haptic feedback)
        let hapticFeedbackEnabled = true;
        let lastHapticTime = 0;
        let hapticCooldown = 600; // мс між вібраціями (для 0.5 сек сигналу)
        
        // Функція оновлення привітального тексту з конфігурації
        function updateWelcomeText() {
            if (config && config.settings && config.settings.welcomeText) {
                const textWrapper = document.getElementById('text-wrapper');
                if (textWrapper) {
                    textWrapper.innerHTML = config.settings.welcomeText;
                }
            }
        }

        // Функція перевірки наявності файлів з config.json (async)
        async function validateConfigFiles() {
            const missingFiles = [];
            const warnings = [];

            if (!config || !config.markers) {
                return { missing: missingFiles, warnings: warnings };
            }

            // Створюємо масив промісів для перевірки всіх файлів
            const checkPromises = [];

            // Перевірка системних файлів
            checkPromises.push(
                checkFileExists('data/helvetiker_regular.typeface.json')
                    .then(exists => {
                        if (!exists) {
                            missingFiles.push({ file: 'data/helvetiker_regular.typeface.json', context: 'System font file' });
                        }
                    })
            );

            // Перевірка кожного маркера
            config.markers.forEach((marker, index) => {
                const markerInfo = `Marker id:${marker.id}`;

                // Перевірка аудіо файлів
                if (marker.audioFile) {
                    checkPromises.push(
                        checkFileExists(marker.audioFile)
                            .then(exists => {
                                if (!exists) {
                                    missingFiles.push({ file: marker.audioFile, context: `${markerInfo} - audio file` });
                                }
                            })
                    );
                }

                // Перевірка файлів для primitive контенту
                if (marker.contentType === 'primitive' && marker.primitive) {
                    if (marker.primitive.textureFile) {
                        checkPromises.push(
                            checkFileExists(marker.primitive.textureFile)
                                .then(exists => {
                                    if (!exists) {
                                        missingFiles.push({ file: marker.primitive.textureFile, context: `${markerInfo} - primitive texture` });
                                    }
                                })
                        );
                    }
                }

                // Перевірка файлів для image контенту
                if (marker.contentType === 'image' && marker.contentFile) {
                    checkPromises.push(
                        checkFileExists(marker.contentFile)
                            .then(exists => {
                                if (!exists) {
                                    missingFiles.push({ file: marker.contentFile, context: `${markerInfo} - image content` });
                                }
                            })
                    );
                }

                // Перевірка файлів для video контенту
                if (marker.contentType === 'video' && marker.contentFile) {
                    checkPromises.push(
                        checkFileExists(marker.contentFile)
                            .then(exists => {
                                if (!exists) {
                                    missingFiles.push({ file: marker.contentFile, context: `${markerInfo} - video content` });
                                }
                            })
                    );
                }

                // Перевірка файлів для model контенту
                if (marker.contentType === 'model' && marker.contentFile) {
                    checkPromises.push(
                        checkFileExists(marker.contentFile)
                            .then(exists => {
                                if (!exists) {
                                    missingFiles.push({ file: marker.contentFile, context: `${markerInfo} - 3D model` });
                                }
                            })
                    );
                }

                // Перевірка файлів для multiplex-3D контенту
                if (marker.contentType === 'multiplex-3D' && marker.multiplex3D) {
                    // Додаємо перевірку config-3D-objects.json
                    checkPromises.push(
                        checkFileExists('config-3D-objects.json')
                            .then(exists => {
                                if (!exists) {
                                    missingFiles.push({ file: 'config-3D-objects.json', context: `${markerInfo} - 3D objects config` });
                                }
                            })
                    );
                }

                // Перевірка alternative content
                if (marker.alternativeContent) {
                    const alt = marker.alternativeContent;
                    const altContext = `${markerInfo} - alternative content`;

                    if (alt.contentType === 'model' && alt.contentFile) {
                        checkPromises.push(
                            checkFileExists(alt.contentFile)
                                .then(exists => {
                                    if (!exists) {
                                        missingFiles.push({ file: alt.contentFile, context: `${altContext} - 3D model` });
                                    }
                                })
                        );
                    }

                    if (alt.contentType === 'primitive' && alt.primitive && alt.primitive.textureFile) {
                        checkPromises.push(
                            checkFileExists(alt.primitive.textureFile)
                                .then(exists => {
                                    if (!exists) {
                                        missingFiles.push({ file: alt.primitive.textureFile, context: `${altContext} - primitive texture` });
                                    }
                                })
                        );
                    }

                    if (alt.contentType === 'image' && alt.contentFile) {
                        checkPromises.push(
                            checkFileExists(alt.contentFile)
                                .then(exists => {
                                    if (!exists) {
                                        missingFiles.push({ file: alt.contentFile, context: `${altContext} - image` });
                                    }
                                })
                        );
                    }

                    if (alt.contentType === 'video' && alt.contentFile) {
                        checkPromises.push(
                            checkFileExists(alt.contentFile)
                                .then(exists => {
                                    if (!exists) {
                                        missingFiles.push({ file: alt.contentFile, context: `${altContext} - video` });
                                    }
                                })
                        );
                    }

                    // Перевірка файлів для multiplex-3D alternative content
                    if (alt.contentType === 'multiplex-3D' && alt.multiplex3D) {
                        // Додаємо перевірку config-3D-objects.json
                        checkPromises.push(
                            checkFileExists('config-3D-objects.json')
                                .then(exists => {
                                    if (!exists) {
                                        missingFiles.push({ file: 'config-3D-objects.json', context: `${altContext} - 3D objects config` });
                                    }
                                })
                        );
                    }
                }
            });

            // Чекаємо завершення всіх перевірок
            await Promise.all(checkPromises);

            return { missing: missingFiles, warnings: warnings };
        }

        // Допоміжна функція для перевірки існування файлу
        async function checkFileExists(url) {
            try {
                const response = await fetch(url, { method: 'HEAD' });
                return response.ok;
            } catch (e) {
                return false;
            }
        }

        // Функція відображення попереджень про відсутні файли
        function showFileWarnings(missingFiles) {
            if (missingFiles.length === 0) return;

            let warningHTML = '<div style="position: fixed; top: 10px; right: 10px; max-width: 400px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; font-family: Arial, sans-serif; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 9999;">' +
                '<strong style="color: #856404; display: block; margin-bottom: 10px; font-size: 16px;">⚠️ Missing Files Warning</strong>' +
                '<ul style="margin: 0; padding-left: 20px; color: #856404; max-height: 300px; overflow-y: auto;">';

            missingFiles.forEach(item => {
                warningHTML += `<li style="margin-bottom: 5px;"><strong>${item.file}</strong> - ${item.context}</li>`;
            });

            warningHTML += '</ul>' +
                '<button onclick="this.parentElement.parentElement.remove()" style="margin-top: 10px; padding: 5px 15px; background: #ffc107; border: none; border-radius: 4px; cursor: pointer; color: #856404; font-weight: bold;">Dismiss</button>' +
                '</div>';

            // Додаємо попередження до сторінки
            const warningDiv = document.createElement('div');
            warningDiv.innerHTML = warningHTML;
            document.body.appendChild(warningDiv.firstChild);

            // Також виводимо в консоль
            console.warn('=== MISSING FILES WARNING ===');
            missingFiles.forEach(item => {
                console.warn(`File not found: ${item.file} (${item.context})`);
            });
            console.warn('==============================');
        }

        // Завантажуємо конфігурацію з config.json при завантаженні сторінки для відображення привітального тексту
        fetch('config.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Config file error: ${response.status} ${response.statusText}`);
                }
                return response.json();
            })
            .then(async data => {
                config = data;
                // Оновлюємо привітальний текст з конфігурації
                updateWelcomeText();
                // Перевіряємо наявність файлів з config.json
                const validationResult = await validateConfigFiles();
                if (validationResult.missing.length > 0) {
                    showFileWarnings(validationResult.missing);
                }
            })
            .catch(error => {
                console.error('Error loading config for welcome text:', error);
                // Залишаємо стандартний текст "Loading..." у випадку помилки
            });

        function initiateExperience() {
            // Оголошуємо глобальні змінні
            var scene, camera, renderer, clock, deltaTime, totalTime;

            var patternIdOffset = 10000000000

            // Змінні необхідні для роботи AR оточення
            var arToolkitSource, arToolkitContext;

            // Головний контейнер, до якого увійдуть всі 3D об'єкти для програми
            var markerRoot, mainContainer;
            var markerRoots; // expose marker roots to update loop

            // Окремий масив для зберігання всього аудіо та відео контенту, який буде
            // запущений натисканням на екран смартфона
            var audioContent = [];

            var contentPromises = [];

            let contentInitialized = false;
            let barcodesSound = new Map();
            let patternsSound = new Map();
            let barcodesID = [];
            let patternsID = [];
            // Map barcode values and pattern names to marker indices for audio lookup
            let barcodeToMarkerIndex = new Map();
            let patternToMarkerIndex = new Map();

            let arucoControls = [];

            let controller;
            
            // Audio context для тактильного звукового відгуку
            let audioContext = null;
            
            // Функція для відтворення короткого аудіо-кліку при дотику
            function playTouchSound() {
                // Ініціалізація AudioContext при першому виклику
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Створення аудіо-сигналу (синусоїда 800 Гц, 500 мс)
                var oscillator = audioContext.createOscillator();
                var gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // Частота 800 Гц
                oscillator.type = 'sine'; // Синусоїда
                
                // Гучність: плавне загасання протягом 0.5 сек
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); // 500 мс
            }

            // Track current content state for each marker (true = alternative content, false = first content)
            let markerContentState = new Map();
            
            // Track which markers have already played sound for current intersection
            let markerSoundPlayed = new Set();
            
            // Store audio timeout IDs for each marker (to cancel if controller moves away)
            let markerAudioTimeouts = new Map();
            
            // Store alternative content objects for each marker
            let markerAlternativeContent = new Map();
            
            // Track which marker is currently intersected by controller tip (for audio playback)
            let currentIntersectedMarker = null;
            
            // Track which markers have already played audio (to avoid replaying while intersecting)
            let markerAudioPlayed = new Set();
            
            // Font for text geometry
            let font = null;
            let fontLoader = new THREE.FontLoader();

            // Load font for text geometry (load once, reuse for all text objects)
            const fontPromise = new Promise((resolve, reject) => {
                fontLoader.load('data/helvetiker_regular.typeface.json', (loadedFont) => {
                    font = loadedFont;
                    resolve(loadedFont);
                }, undefined, (error) => {
                    console.error('Error loading font:', error);
                    reject(error);
                });
            });

            // Використовуємо глобальну функцію updateWelcomeText(), яку ми вже визначили вище
            
            // Function to create alternative content object based on configuration
            function createAlternativeContent(markerIndex, alternativeContentConfig) {
                if (!alternativeContentConfig) return null;
                
                const markerRoot = markerRoots[markerIndex];
                if (!markerRoot) return null;
                
                switch (alternativeContentConfig.contentType) {
                    case 'model':
                        return createAlternativeModelContent(markerRoot, alternativeContentConfig);
                    case 'primitive':
                        return createAlternativePrimitiveContent(markerRoot, alternativeContentConfig);
                    case 'image':
                        return createAlternativeImageContent(markerRoot, alternativeContentConfig);
                    case 'video':
                        return createAlternativeVideoContent(markerRoot, alternativeContentConfig);
                    case 'text':
                        return createAlternativeTextContent(markerRoot, alternativeContentConfig);
                    case 'multiplex-3D':
                        return createAlternativeMultiplex3DContent(markerRoot, alternativeContentConfig);
                    default:
                        return null;
                }
            }
            
            // Function to create model content for alternative content
            function createAlternativeModelContent(markerRoot, config) {
                return new Promise((resolve) => {
                    const loader = new THREE.GLTF2Loader();
                    loader.load(config.contentFile, (response) => {
                        const scene = response.scene;
                        const object = scene.children[0];
                        
                        if (config.modelScale) {
                            const scale = config.modelScale;
                            object.scale.set(scale, scale, scale);
                        }
                        
                        if (config.position) {
                            const pos = config.position;
                            object.position.set(pos.x || 0, pos.y || 0, pos.z || 0);
                        }
                        
                        if (config.rotation) {
                            const rot = config.rotation;
                            object.rotation.set(rot.x || 0, rot.y || 0, rot.z || 0);
                        }
                        
                        if (config.animation) {
                            object.userData.animation = config.animation;
                        }
                        
                        object.userData.isAlternativeContent = true;
                        resolve(object);
                    });
                });
            }
            
            // Function to create primitive content for alternative content
            function createAlternativePrimitiveContent(markerRoot, config) {
                const primitive = config.primitive;
                let geometry, material, mesh;
                
                switch(primitive.type) {
                    case 'BoxGeometry':
                        geometry = new THREE.BoxGeometry(...primitive.size);
                        break;
                    case 'SphereGeometry':
                        geometry = new THREE.SphereGeometry(primitive.radius, primitive.widthSegments || 32, primitive.heightSegments || 32);
                        break;
                    case 'CylinderGeometry':
                        geometry = new THREE.CylinderGeometry(
                            primitive.radiusTop || 0.5, 
                            primitive.radiusBottom || 0.5, 
                            primitive.height || 1, 
                            primitive.radialSegments || 32
                        );
                        break;
                    case 'ConeGeometry':
                                                                var coneHeight = primitive.height || 1;
                                                                geometry = new THREE.ConeGeometry(
                                                                    primitive.radius || 0.5,
                                                                    coneHeight,
                                                                    primitive.radialSegments || 32
                                                                );
                                                                // Не зміщуємо геометрію - розміщуємо через позицію меша
                                                                break;
                    case 'TorusGeometry':
                        geometry = new THREE.TorusGeometry(
                            primitive.radius || 1, 
                            primitive.tubeRadius || 0.4, 
                            primitive.radialSegments || 16, 
                            primitive.tubularSegments || 32
                        );
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }
                
                if (primitive.textureFile) {
                    let texture = new THREE.TextureLoader().load(primitive.textureFile);
                    material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        color: new THREE.Color(primitive.color || '#ffffff')
                    });
                } else {
                    material = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color(primitive.color || '#ffffff') 
                    });
                }
                
                mesh = new THREE.Mesh(geometry, material);

                if (primitive.position) {
                    mesh.position.set(...primitive.position);
                } else {
                    // Автоматичне зміщення для примітивів, щоб основа була на Y=0
                    // Це запобігає візуальному зміщенню при погляді під кутом
                    if (primitive.type === 'BoxGeometry' && primitive.size) {
                        mesh.position.y = primitive.size[1] / 2; // половина висоти куба
                    } else if (primitive.type === 'ConeGeometry' && primitive.height) {
                        mesh.position.y = primitive.height / 2;
                    } else if (primitive.type === 'CylinderGeometry' && primitive.height) {
                        mesh.position.y = primitive.height / 2;
                    }
                }
                if (primitive.rotation) {
                    mesh.rotation.set(...primitive.rotation);
                }
                
                if (primitive.animation) {
                    mesh.userData.animation = config.animation;
                }
                
                mesh.userData.isAlternativeContent = true;
                return Promise.resolve(mesh);
            }
            
            // Function to create image content for alternative content
            function createAlternativeImageContent(markerRoot, config) {
                return new Promise((resolve) => {
                    let loader = new THREE.TextureLoader();
                    loader.load(config.contentFile, (texture) => {
                        let geometry, ratio = texture.image.naturalWidth / texture.image.naturalHeight;
                        if (texture.image.naturalHeight < texture.image.naturalWidth) {
                            geometry = new THREE.PlaneBufferGeometry(ratio, 1);
                        } else {
                            geometry = new THREE.PlaneBufferGeometry(1, 1 / ratio);
                        }
                        let material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                        let mesh = new THREE.Mesh(geometry, material);
                        mesh.rotation.x = -Math.PI / 2;
                        mesh.userData.isAlternativeContent = true;
                        resolve(mesh);
                    });
                });
            }
            
            // Function to create video content for alternative content
            function createAlternativeVideoContent(markerRoot, config) {
                let geometry = new THREE.PlaneBufferGeometry(1.6, 0.9);
                let video = document.createElement('video');
                video.src = config.contentFile;
                video.playsInline = true;
                
                let texture = new THREE.VideoTexture(video);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.format = THREE.RGBFormat;
                let material = new THREE.MeshBasicMaterial({ map: texture });
                let mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.userData.isAlternativeContent = true;
                
                return Promise.resolve({ mesh, video });
            }
            
            // Function to create text content for alternative content
            function createAlternativeTextContent(markerRoot, config) {
                return fontPromise.then((font) => {
                    if (!config.text) return null;

                    const textConfig = config.text || {};
                    const textParams = {
                        font: font,
                        size: textConfig.size || 0.5,
                        height: textConfig.height || 0.1,
                        curveSegments: textConfig.curveSegments || 12,
                        bevelEnabled: textConfig.bevelEnabled || false,
                        bevelThickness: textConfig.bevelThickness || 0.03,
                        bevelSize: textConfig.bevelSize || 0.02
                    };

                    const geometry = new THREE.TextGeometry(textConfig.content || 'Text', textParams);
                    geometry.computeBoundingBox();

                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(textConfig.color || '#ffffff')
                    });

                    const mesh = new THREE.Mesh(geometry, material);

                    // Center the text
                    const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
                    mesh.position.x = xMid;

                    if (textConfig.position) {
                        const pos = textConfig.position;
                        mesh.position.x += (pos.x || 0);
                        mesh.position.y = pos.y || 0;
                        mesh.position.z = pos.z || 0;
                    }

                    if (textConfig.rotation) {
                        const rot = textConfig.rotation;
                        mesh.rotation.set(rot.x || 0, rot.y || 0, rot.z || 0);
                    }

                    if (textConfig.animation) {
                        mesh.userData.animation = config.animation;
                    }

                    mesh.userData.isAlternativeContent = true;
                    return mesh;
                });
            }

            // Функція для створення складного 3D-об'єкта (multiplex-3D) з конфігурації
            function createMultiplex3DObject(markerRoot, objectConfig) {
                if (!objectConfig || !objectConfig.part) {
                    return Promise.resolve(null);
                }

                const group = new THREE.Group();
                const partsPromises = [];

                // Створюємо кожну частину складного об'єкта
                objectConfig.part.forEach(partConfig => {
                    const partPromise = new Promise((resolve) => {
                        let geometry, material, mesh;

                        // Створюємо геометрію відповідно до типу
                        switch(partConfig.type) {
                            case 'BoxGeometry':
                                geometry = new THREE.BoxGeometry(...partConfig.size);
                                break;
                            case 'SphereGeometry':
                                geometry = new THREE.SphereGeometry(partConfig.radius, partConfig.widthSegments || 32, partConfig.heightSegments || 32);
                                break;
                            case 'CylinderGeometry':
                                geometry = new THREE.CylinderGeometry(
                                    partConfig.radiusTop || 0.5,
                                    partConfig.radiusBottom || 0.5,
                                    partConfig.height || 1,
                                    partConfig.radialSegments || 32
                                );
                                break;
                            case 'ConeGeometry':
                                var coneHeight = partConfig.height || 1;
                                geometry = new THREE.ConeGeometry(
                                    partConfig.radius || 0.5,
                                    coneHeight,
                                    partConfig.radialSegments || 32
                                );
                                // Не зміщуємо геометрію - розміщуємо через позицію меша
                                break;
                            case 'TorusGeometry':
                                geometry = new THREE.TorusGeometry(
                                    partConfig.radius || 1,
                                    partConfig.tubeRadius || 0.4,
                                    partConfig.radialSegments || 16,
                                    partConfig.tubularSegments || 32
                                );
                                break;
                            default:
                                geometry = new THREE.BoxGeometry(1, 1, 1);
                        }

                        // Створюємо матеріал з кольором або текстурою
                        if (partConfig.textureFile) {
                            // Завантажуємо текстуру, якщо вона вказана
                            let texture = new THREE.TextureLoader().load(partConfig.textureFile);
                            material = new THREE.MeshBasicMaterial({
                                map: texture,
                                color: new THREE.Color(partConfig.color || '#ffffff')
                            });
                        } else {
                            // Використовуємо колір, якщо текстура не вказана
                            material = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(partConfig.color || '#ffffff')
                            });
                        }

                        // Створюємо меш
                        mesh = new THREE.Mesh(geometry, material);

                        // Застосовуємо позицію та обертання, якщо вказані
                        if (partConfig.position) {
                            mesh.position.set(...partConfig.position);
                        }
                        if (partConfig.rotation) {
                            mesh.rotation.set(...partConfig.rotation);
                        }

                        // Зберігаємо анімацію для частини
                        if (partConfig.animation) {
                            mesh.userData.animation = partConfig.animation;
                        }

                        resolve(mesh);
                    });

                    partsPromises.push(partPromise);
                });

                // Чекаємо завершення створення всіх частин
                return Promise.all(partsPromises).then((parts) => {
                    parts.forEach(part => {
                        group.add(part);
                    });
                    group.userData.isMultiplex3D = true;
                    return group;
                });
            }
            
            // Функція для створення alternative multiplex-3D контенту
            // Складний 3D-об'єкт, де кожна частина розміщується зверху попередньої
            function createAlternativeMultiplex3DContent(markerRoot, config) {
                // Підтримка обох форматів: multiplex3D: 1 або multiplex3D: { object_id: 1 }
                let objectId;
                if (typeof config.multiplex3D === 'number') {
                    objectId = config.multiplex3D;
                } else if (config.multiplex3D && config.multiplex3D.object_id) {
                    objectId = config.multiplex3D.object_id;
                } else {
                    return Promise.resolve(null);
                }

                // Завантажуємо конфігурацію об'єкта з config-3D-objects.json
                return fetch('config-3D-objects.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to load config-3D-objects.json');
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Знаходимо об'єкт з потрібним object_id
                        const objectConfig = data.objects.find(obj => obj.object_id === objectId);
                        if (!objectConfig) {
                            console.error(`Object with id ${objectId} not found in config-3D-objects.json`);
                            return null;
                        }

                        console.log(`Loaded object ${objectId}: ${objectConfig.name}, parts: ${objectConfig.part.length}`);
                        console.log('Parts config:', JSON.stringify(objectConfig.part, null, 2));

                        const group = new THREE.Group();
                        let currentHeight = 0; // Поточна висота для стек-розміщення

                        // Створюємо кожну частину складного об'єкта
                        // Сортуємо частини за part_id для правильного порядку
                        const sortedParts = [...objectConfig.part].sort((a, b) => a.part_id - b.part_id);

                        sortedParts.forEach(partConfig => {
                            let geometry, material, mesh;

                            // Створюємо геометрію відповідно до типу
                            switch(partConfig.type) {
                                case 'BoxGeometry':
                                    geometry = new THREE.BoxGeometry(...partConfig.size);
                                    break;
                                case 'SphereGeometry':
                                    geometry = new THREE.SphereGeometry(partConfig.radius, partConfig.widthSegments || 32, partConfig.heightSegments || 32);
                                    break;
                                case 'CylinderGeometry':
                                    geometry = new THREE.CylinderGeometry(
                                        partConfig.radiusTop || 0.5,
                                        partConfig.radiusBottom || 0.5,
                                        partConfig.height || 1,
                                        partConfig.radialSegments || 32
                                    );
                                    break;
                                case 'ConeGeometry':
                                    var coneHeight = partConfig.height || 1;
                                    geometry = new THREE.ConeGeometry(
                                        partConfig.radius || 0.5,
                                        coneHeight,
                                        partConfig.radialSegments || 32
                                    );
                                    // Не зміщуємо геометрію - розміщуємо через позицію меша
                                    break;
                                case 'TorusGeometry':
                                    geometry = new THREE.TorusGeometry(
                                        partConfig.radius || 1,
                                        partConfig.tubeRadius || 0.4,
                                        partConfig.radialSegments || 16,
                                        partConfig.tubularSegments || 32
                                    );
                                    break;
                                default:
                                    geometry = new THREE.BoxGeometry(1, 1, 1);
                            }

                            // Створюємо матеріал з кольором або текстурою
                            if (partConfig.textureFile) {
                                // Завантажуємо текстуру, якщо вона вказана
                                let texture = new THREE.TextureLoader().load(partConfig.textureFile);
                                material = new THREE.MeshBasicMaterial({
                                    map: texture,
                                    color: new THREE.Color(partConfig.color || '#ffffff')
                                });
                            } else {
                                // Використовуємо колір, якщо текстура не вказана
                                material = new THREE.MeshBasicMaterial({
                                    color: new THREE.Color(partConfig.color || '#ffffff')
                                });
                            }

                            // Створюємо меш
                            mesh = new THREE.Mesh(geometry, material);

                            // Розміщуємо частину на потрібній висоті
                            // Варіант 1: Абсолютні координати (positionX, positionY, positionZ) - для складних форм
                            // Варіант 2: Стек-розміщення (автоматичне) - для простих вертикальних структур
                            console.log(`Part ${partConfig.part_id}: type=${partConfig.type}, positionY=${partConfig.positionY}, positionX=${partConfig.positionX}, positionZ=${partConfig.positionZ}, currentHeight=${currentHeight}`);
                            
                            if (partConfig.positionY !== undefined) {
                                // Використовуємо абсолютну позицію Y з конфігурації
                                // Додаємо половину висоти об'єкта для центрування
                                var partHeight = 0;
                                if (partConfig.height) {
                                    partHeight = partConfig.height;
                                } else if (partConfig.size && partConfig.size[1]) {
                                    partHeight = partConfig.size[1];
                                } else if (partConfig.radius) {
                                    partHeight = partConfig.radius * 2;
                                } else if (partConfig.tubeRadius) {
                                    partHeight = partConfig.tubeRadius * 2;
                                }
                                mesh.position.y = partConfig.positionY + partHeight / 2;
                                console.log(`  -> Абсолютна позиція Y: ${mesh.position.y} (positionY=${partConfig.positionY} + partHeight/2=${partHeight/2})`);
                            } else if (partConfig.type === 'BoxGeometry' && partConfig.size) {
                                // Куб/прямокутник: висота = size[1] (Y-розмір)
                                mesh.position.y = currentHeight + partConfig.size[1] / 2;
                                currentHeight += partConfig.size[1];
                            } else if (partConfig.type === 'CylinderGeometry' && partConfig.height) {
                                // Циліндр: центр посередині висоти
                                mesh.position.y = currentHeight + partConfig.height / 2;
                                currentHeight += partConfig.height;
                            } else if (partConfig.type === 'ConeGeometry' && partConfig.height) {
                                // Конус: центр посередині висоти, основа на currentHeight
                                mesh.position.y = currentHeight + partConfig.height / 2;
                                currentHeight += partConfig.height;
                            } else if (partConfig.type === 'SphereGeometry' && partConfig.radius) {
                                // Сфера: центр в центрі сфери, нижня точка на currentHeight
                                mesh.position.y = currentHeight + partConfig.radius;
                                currentHeight += 2 * partConfig.radius; // діаметр
                            } else if (partConfig.type === 'TorusGeometry' && partConfig.tubeRadius) {
                                // Тор: центр в центрі тора, нижня точка на currentHeight
                                mesh.position.y = currentHeight + partConfig.tubeRadius;
                                currentHeight += 2 * partConfig.tubeRadius; // діаметр труби
                            } else {
                                // Для інших фігур або якщо висота не вказана
                                mesh.position.y = currentHeight + 0.5;
                                currentHeight += 1;
                            }

                            // Додаткові координати X, Z (якщо вказані)
                            if (partConfig.positionX !== undefined) {
                                mesh.position.x = partConfig.positionX;
                                console.log(`  -> positionX: ${mesh.position.x}`);
                            }
                            if (partConfig.positionZ !== undefined) {
                                mesh.position.z = partConfig.positionZ;
                                console.log(`  -> positionZ: ${mesh.position.z}`);
                            }

                            // Застосовуємо обертання, якщо вказане
                            if (partConfig.rotation) {
                                mesh.rotation.set(...partConfig.rotation);
                            }
                            // Індивідуальні обертання по осях (якщо вказані окремо)
                            if (partConfig.rotationX !== undefined) {
                                mesh.rotation.x = partConfig.rotationX;
                            }
                            if (partConfig.rotationY !== undefined) {
                                mesh.rotation.y = partConfig.rotationY;
                            }
                            if (partConfig.rotationZ !== undefined) {
                                mesh.rotation.z = partConfig.rotationZ;
                            }

                            // Зберігаємо анімацію для частини
                            if (partConfig.animation) {
                                mesh.userData.animation = partConfig.animation;
                            }

                            group.add(mesh);
                        });

                        group.userData.isAlternativeContent = true;
                        group.userData.isMultiplex3D = true;
                        return group;
                    });
            }
            
            // Function to switch content for a specific marker
            function switchMarkerContent(markerIndex, useAlternativeContent) {
                const markerRoot = markerRoots[markerIndex];
                if (!markerRoot) return;

                const currentState = markerContentState.get(markerIndex) || false;
                if (currentState === useAlternativeContent) return; // Already in the desired state

                if (useAlternativeContent && markerAlternativeContent.has(markerIndex)) {
                    // Switch to alternative content
                    // Hide all current content (main content)
                    markerRoot.children.forEach(child => {
                        if (!(child.userData && child.userData.isController) && !child.userData.isAlternativeContent) {
                            child.visible = false;
                        }
                    });

                    // Show alternative content
                    const alternativeContent = markerAlternativeContent.get(markerIndex);
                    if (Array.isArray(alternativeContent)) {
                        alternativeContent.forEach(content => {
                            if (content.mesh) {
                                content.mesh.visible = true;
                                content.mesh.userData.isAlternativeContent = true;
                                if (!markerRoot.children.includes(content.mesh)) {
                                    markerRoot.add(content.mesh);
                                }
                            } else {
                                content.visible = true;
                                content.userData.isAlternativeContent = true;
                                if (!markerRoot.children.includes(content)) {
                                    markerRoot.add(content);
                                }
                            }
                        });
                    } else if (alternativeContent.mesh) {
                        alternativeContent.mesh.visible = true;
                        alternativeContent.mesh.userData.isAlternativeContent = true;
                        if (!markerRoot.children.includes(alternativeContent.mesh)) {
                            markerRoot.add(alternativeContent.mesh);
                        }
                    } else {
                        alternativeContent.visible = true;
                        alternativeContent.userData.isAlternativeContent = true;
                        if (!markerRoot.children.includes(alternativeContent)) {
                            markerRoot.add(alternativeContent);
                        }
                    }
                } else {
                    // Switch to main content
                    // Hide all alternative content
                    markerRoot.children.forEach(child => {
                        if (!(child.userData && child.userData.isController)) {
                            if (child.userData.isAlternativeContent) {
                                child.visible = false;
                            } else {
                                child.visible = true;
                            }
                        }
                    });
                }

                // Always update state
                markerContentState.set(markerIndex, useAlternativeContent);
            }

            // Завантажуємо конфігурацію з config.json перед ініціалізацією
            fetch('config.json')
                .then(async response => {
                    if (!response.ok) {
                        throw new Error(`Config file error: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(async data => {
                    config = data;
                    // Оновлюємо привітальний текст з конфігурації
                    updateWelcomeText();
                    // Перевіряємо наявність файлів з config.json
                    const validationResult = await validateConfigFiles();
                    if (validationResult.missing.length > 0) {
                        showFileWarnings(validationResult.missing);
                    }
                    // Ініціалізуємо сцену та запускаємо цикл анімації
                    initialize();
                    animate();
                })
                .catch(error => {
                    console.error('Error loading config:', error);
                    // Виводимо помилку на екран
                    loader.style.display = 'block';
                    loader.innerHTML = `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #ff0000; font-family: Arial, sans-serif;">
                        <h3>Configuration Error</h3>
                        <p>Could not load configuration file.</p>
                        <p>${error.message}</p>
                        <p>Please ensure that config.json is present and accessible.</p>
                    </div>`;
                });

            function initialize() {
                // Оголошуємо сцену, в яку додамо головний контейнер з усіма 3D об'єктами.
                scene = new THREE.Scene();

                // Додаємо світло на сцену, інакше базові матеріали будуть просто чорними.
                // т.к. їм нема чого відображати, зверніться до документації бібліотеки three.js, щоб
                // прочитати про докладну роботу класу Material
                let ambientLight = new THREE.AmbientLight(0xffffff, 0.75);
                scene.add(ambientLight);

                // Додаємо камеру, яка буде пізніше перепризначена на камеру смартфона
                camera = new THREE.Camera();
                scene.add(camera);
                const listener = new THREE.AudioListener();
                camera.add(listener);
                const audioLoader = new THREE.AudioLoader();

                // Визначаємо роздільну здатність з конфігурації
                let canvasWidth = 640;
                let canvasHeight = 480;
                
                if (config && config.settings) {
                    switch(config.settings.resolution) {
                        case 'high':
                            canvasWidth = 1280;
                            canvasHeight = 720;
                            break;
                        case 'low':
                        default:
                            canvasWidth = 640;
                            canvasHeight = 480;
                            break;
                    }
                }

                // Оголошуємо стандартний рендерер і додаємо його до тега body html документа
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
                renderer.setClearColor(new THREE.Color('lightgrey'), 0)
                renderer.setSize(canvasWidth, canvasHeight);
                renderer.domElement.style.position = 'absolute'
                renderer.domElement.style.top = '0px'
                renderer.domElement.style.left = '0px'
                document.body.appendChild(renderer.domElement);

                clock = new THREE.Clock();
                deltaTime = 0;
                totalTime = 0;

                arToolkitSource = new THREEx.ArToolkitSource({
                    sourceType: 'webcam',
                });

                // Функція перерендерує AR сцену під поточний розмір canvas
                function onResize() {
                    arToolkitSource.onResize()
                    arToolkitSource.copySizeTo(renderer.domElement)
                    if (arToolkitContext.arController !== null) {
                        arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
                    }
                }

                // Викликаємо функцію під час ініціалізації AR
                arToolkitSource.init(function onReady() {
                    onResize()
                });

                // Викликаємо функцію на resize івент веб-сторінки
                window.addEventListener('resize', function () {
                    onResize()
                });

                // Ініціалізуємо AR контекст під камеру, патерни, баркод 3х3
                arToolkitContext = new THREEx.ArToolkitContext({
                    cameraParametersUrl: 'data/camera_para.dat',
                    detectionMode: 'mono_and_matrix',
                    matrixCodeType: '3x3',
                    maxDetectionRate: -1,  // Вимикаємо обмеження частоти для AR.js (детектуємо самі)
                    canvasWidth: canvasWidth,
                    canvasHeight: canvasHeight
                });

                // Відновлюємо матрицю проекції камери після закінчення ініціалізації
                arToolkitContext.init(function onCompleted() {
                    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                });

                // Створюємо головну групу для всіх 3D об'єктів
                mainContainer = new THREE.Group();

                // Отримуємо дані з конфігурації
                let patternNames = [];
                let patternBarcode = [];
                let modes = [];
                let modelFiles = [];
                let imageFiles = [];
                let videoFiles = [];
                let audioFiles = [];
                let repeatOptions = [];
                
                // Визначаємо кількість маркерів з конфігурації
                let maxMarkers = 0;
                
                // Заповнюємо масиви з конфігурації
                if (config && config.markers) {
                    maxMarkers = config.markers.length;
                    for (let i = 0; i < config.markers.length; i++) {
                        // Для зворотньої сумісності з попереднім кодом
                        if (config.markers[i].type === 'pattern') {
                            patternNames.push(config.markers[i].target);
                            patternBarcode.push(-1);
                        } else {
                            patternNames.push('');
                            patternBarcode.push(config.markers[i].target);
                        }
                        
                        modes.push(config.markers[i].contentType);
                        // Визначаємо тип контенту та встановлюємо відповідний файл
                        switch(config.markers[i].contentType) {
                            case 'model':
                                modelFiles.push(config.markers[i].contentFile || '');
                                imageFiles.push('');
                                videoFiles.push('');
                                break;
                            case 'image':
                                modelFiles.push('');
                                imageFiles.push(config.markers[i].contentFile || '');
                                videoFiles.push('');
                                break;
                            case 'video':
                                modelFiles.push('');
                                imageFiles.push('');
                                videoFiles.push(config.markers[i].contentFile || '');
                                break;
                            case 'text':
                                modelFiles.push('');
                                imageFiles.push('');
                                videoFiles.push('');
                                break;
                            default:
                                modelFiles.push('');
                                imageFiles.push('');
                                videoFiles.push('');
                        }
                        audioFiles.push(config.markers[i].audioFile || '');
                        repeatOptions.push('false'); // Тимчасово, можна додати в конфіг
                    }
                }
  
                // Створюємо масив для всіх маркерів
                markerRoots = [];
                for (let i = 0; i < maxMarkers; i++) {
                    markerRoots[i] = new THREE.Group();
                }
  
                // Проходимо по кожному маркеру з масиву і додаємо його в головний контейнер
                for (let i = 0; i < maxMarkers; i++) {
                    mainContainer.add(markerRoots[i]);

                    const markerConfig = config.markers[i];
                    // Визначаємо тип маркера і створюємо відповідний контролер
                    if (markerConfig.type === 'pattern') {
                        let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoots[i], {
                            type: 'pattern',
                            patternUrl: "patterns/pattern-" + markerConfig.target + ".patt",
                        });
                        patternsID.push(markerConfig.target);
                        patternToMarkerIndex.set(markerConfig.target, i);
                    } else if (markerConfig.type === 'barcode') {
                        let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoots[i], {
                            type: "barcode",
                            barcodeValue: markerConfig.target,
                            size: markerConfig.matrixSize
                        });
                        barcodesID.push(markerConfig.target);
                        barcodeToMarkerIndex.set(markerConfig.target, i);
                    } else if (markerConfig.type.startsWith('aruco:')) {
                        const dictionaryName = markerConfig.type.split(':')[1];
                        let markerControls = new ArucoMarkerControls(arToolkitContext, markerRoots[i], {
                            id: markerConfig.target,
                            dictionaryName: dictionaryName,
                            modelSize: markerConfig.matrixSize || 30.0 // Розмір маркера в мм з конфігурації
                        }, canvasWidth);
                        arucoControls.push(markerControls);
                    }

                    // Create alternative content if it exists in configuration
                    if (config.markers[i] && config.markers[i].alternativeContent) {
                        const alternativeContentPromise = createAlternativeContent(i, config.markers[i].alternativeContent);
                        if (alternativeContentPromise) {
                            contentPromises.push(alternativeContentPromise.then((alternativeContent) => {
                                if (alternativeContent) {
                                    markerAlternativeContent.set(i, alternativeContent);
                                    // console.log(`Alternative content for marker ${i} created`); // Diagnostic message removed
                                }
                            }));
                        }
                    }

                    // Використовуємо switch для роботи з кожним окремим випадком контенту
                    switch (modes[i]) {
                        // Якщо контент під маркер це модель
                        case 'model':
                                                            function onProgress(xhr) { /* console.log((xhr.loaded / xhr.total * 100) + '% loaded'); */ }                            function onError(xhr) { /* console.log('An error happened'); */ }

                            contentPromises.push(new Promise((resolve) => {
                                const test = new THREE.GLTF2Loader().load(`${modelFiles[i]}`, (response) => {
                                    const scene = response.scene;
                                    const object = scene.children[0];
									
                                    // Іноді модель не можна побачити з кількох причин, найчастіше варто збільшити чи зменшити у 100 разів.
                                    // Читайте: https://threejs.org/docs/index.html#manual/en/introduction/Loading-3D-models
                                    // Тут ми зменшуємо її, щоб точно побачити її на сцені. Ви можете видалити цю шкалу, якщо потрібно
                                    // Використовуємо modelScale з конфігурації, якщо він вказаний
                                    if (config.markers[i] && config.markers[i].modelScale) {
                                        const scale = config.markers[i].modelScale;
                                        object.scale.set(scale, scale, scale);
                                    }
									
                    // Ви можете самостійно змінити поворот або позицію моделі
                    // object.position.set(X, Y, Z);
					// X - право (+) или влево (-) от камеры
					// Y - вверх (+) или вниз (-) от камеры
				    	// Z - ближе (+) или дальше (-) от камеры
					// Використовуємо position з конфігурації, якщо він вказаний
                    if (config.markers[i] && config.markers[i].position) {
                        const pos = config.markers[i].position;
                        object.position.set(
                            pos.x || 0,
                            pos.y || 0,
                            pos.z || 0
                        );
                    }
					
				    // object.rotation.set(X_angle, Y_angle, Z_angle), 
				    //
				    // Z_angle - угол вперед (+) или назад (-) от положения камеры
				    // Math.PI - 180 градусов
                    //object.rotation.set(0, Math.PI, Math.PI);
				    // Використовуємо rotation з конфігурації, якщо він вказаний
                    if (config.markers[i] && config.markers[i].rotation) {
                        const rot = config.markers[i].rotation;
                        object.rotation.set(
                            rot.x || 0,
                            rot.y || 0,
                            rot.z || 0
                        );
                    }
					
                                    // Додавання нашої моделі до контейнера групи маркерів
                                    markerRoots[i].add(object);
                                    
                                    // Зберігаємо для анімації, якщо вказана в конфігурації
                                    if (config.markers[i] && config.markers[i].animation) {
                                        object.userData.animation = config.markers[i].animation;
                                    }
                                    
                                    resolve(modelFiles[i])
                                }, onProgress, onError)
                            }).then((file) => {
                                // console.log(`File ${file} loaded`) // Diagnostic message removed
                            }))
                            break;
                        // Якщо контент під маркер це зображення
                        case 'image':
                            if (imageFiles[i]) {
                                contentPromises.push(new Promise((resolve) => {
                                    // Завантажуємо зображення
                                    let loader = new THREE.TextureLoader();
                                    loader.load(`${imageFiles[i]}`, (texture) => {
                                        let geometry1, ratio = texture.image.naturalWidth / texture.image.naturalHeight;
                                        if (texture.image.naturalHeight < texture.image.naturalWidth) {
                                            geometry1 = new THREE.PlaneBufferGeometry(ratio, 1);
                                        } else {
                                            geometry1 = new THREE.PlaneBufferGeometry(1, 1 / ratio);
                                        }
                                        let material1 = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                                        mesh1 = new THREE.Mesh(geometry1, material1);
                                        // Повертаємо площину
                                        mesh1.rotation.x = -Math.PI / 2;
                                        // Додаємо площину у контейнер
                                        markerRoots[i].add(mesh1);
                                        resolve(imageFiles[i])
                                    });
                                }).then(image => {
                                    // console.log(`File ${image} loaded`) // Diagnostic message removed
                                }))
                            }
                            break;
                        // Якщо контент під маркер - це відео
                        case 'video':
                            // Оголошуємо площину під відео
                            let geometry2 = new THREE.PlaneBufferGeometry(1.6 , 0.9);
                            // Оголошуємо та завантажуємо відео
                            let video = document.createElement('video');
                            video.src = `${videoFiles[i]}`;
                            video.playsInline = true;
                            // Встановлюємо відео на автоповтор залежно від значення у масиві
                            if (repeatOptions[i]) {
                                video.addEventListener('ended', () => {
                                    video.play();
                                })
                            }
                            // Check if video should only play on controller intersection
                            let playOnControllerIntersect = config.markers[i] && config.markers[i].playOnControllerIntersect === true;
                            
                            // Store video object with flag
                            let videoData = {
                                sound: video,
                                playOnControllerIntersect: playOnControllerIntersect
                            };
                            
                            // Додаємо відео до масиву аудіо контенту
                            if (patternBarcode[i] === -1) {
                                patternsSound.set(i, videoData);
                            } else {
                                barcodesSound.set(patternBarcode[i], videoData);
                            }
                            // Перенаправляємо текстуру з відео на матеріал для площини.
                            let texture2 = new THREE.VideoTexture(video);
                            texture2.minFilter = THREE.LinearFilter;
                            texture2.magFilter = THREE.LinearFilter;
                            texture2.format = THREE.RGBFormat;
                            let material2 = new THREE.MeshBasicMaterial({ map: texture2 });
                            mesh2 = new THREE.Mesh(geometry2, material2);
                            // Повертаємо площину
                            mesh2.rotation.x = -Math.PI / 2;
                            // Встановлюємо позицію для відео-площини, щоб узгодити з іншими об'єктами
                            if (config.markers[i] && config.markers[i].position) {
                                const pos = config.markers[i].position;
                                mesh2.position.set(
                                    pos.x || 0,
                                    pos.y || 0,
                                    pos.z || 0
                                );
                            }
                            // Додаємо площину у контейнер
                            markerRoots[i].add(mesh2);
                            break;
                        // Якщо контент під маркер - це примітив
                        case 'primitive':
                            if (config.markers[i] && config.markers[i].primitive) {
                                const primitive = config.markers[i].primitive;
                                let geometry, material, mesh;

                                // Створюємо геометрію відповідно до типу
                                switch(primitive.type) {
                                    case 'BoxGeometry':
                                        geometry = new THREE.BoxGeometry(...primitive.size);
                                        break;
                                    case 'SphereGeometry':
                                        geometry = new THREE.SphereGeometry(primitive.radius, primitive.widthSegments || 32, primitive.heightSegments || 32);
                                        break;
                                    case 'CylinderGeometry':
                                        geometry = new THREE.CylinderGeometry(
                                            primitive.radiusTop || 0.5,
                                            primitive.radiusBottom || 0.5,
                                            primitive.height || 1,
                                            primitive.radialSegments || 32
                                        );
                                        break;
                                    case 'ConeGeometry':
                                        var coneHeight = primitive.height || 1;
                                        geometry = new THREE.ConeGeometry(
                                            primitive.radius || 0.5,
                                            coneHeight,
                                            primitive.radialSegments || 32
                                        );
                                        // Не зміщуємо геометрію - розміщуємо через позицію меша
                                        break;
                                    case 'TorusGeometry':
                                        geometry = new THREE.TorusGeometry(
                                            primitive.radius || 1,
                                            primitive.tubeRadius || 0.4,
                                            primitive.radialSegments || 16,
                                            primitive.tubularSegments || 32
                                        );
                                        break;
                                    default:
                                        geometry = new THREE.BoxGeometry(1, 1, 1);
                                }

                                // Створюємо матеріал з кольором або текстурою
                                if (primitive.textureFile) {
                                    // Завантажуємо текстуру, якщо вона вказана
                                    let texture = new THREE.TextureLoader().load(primitive.textureFile);
                                    material = new THREE.MeshBasicMaterial({
                                        map: texture,
                                        color: new THREE.Color(primitive.color || '#ffffff') // Додаємо базовий колір для випадку, якщо текстура не завантажиться
                                    });
                                } else {
                                    // Використовуємо колір, якщо текстура не вказана
                                    material = new THREE.MeshBasicMaterial({
                                        color: new THREE.Color(primitive.color || '#ffffff')
                                    });
                                }

                                // Створюємо меш
                                mesh = new THREE.Mesh(geometry, material);

                                // Застосовуємо позицію та обертання
                                if (primitive.position) {
                                    mesh.position.set(...primitive.position);
                                } else {
                                    // Автоматичне зміщення для примітивів, щоб основа була на Y=0
                                    // Це запобігає візуальному зміщенню при погляді під кутом
                                    if (primitive.type === 'BoxGeometry' && primitive.size) {
                                        mesh.position.y = primitive.size[1] / 2; // половина висоти куба
                                    } else if (primitive.type === 'ConeGeometry' && primitive.height) {
                                        mesh.position.y = primitive.height / 2;
                                    } else if (primitive.type === 'CylinderGeometry' && primitive.height) {
                                        mesh.position.y = primitive.height / 2;
                                    }
                                }
                                if (primitive.rotation) {
                                    mesh.rotation.set(...primitive.rotation);
                                }

                                // Додаємо до контейнера маркера
                                markerRoots[i].add(mesh);

                                // Зберігаємо для анімації
                                if (primitive.animation) {
                                    mesh.userData.animation = primitive.animation;
                                }
                            }
                            // Add a resolved promise to contentPromises for primitive content
                            contentPromises.push(Promise.resolve());
                            break;
                        case 'text':
                            if (config.markers[i] && config.markers[i].text) {
                                contentPromises.push(fontPromise.then((font) => {
                                    const textConfig = config.markers[i].text || {};
                                    const textParams = {
                                        font: font,
                                        size: textConfig.size || 0.5,
                                        height: textConfig.height || 0.1,
                                        curveSegments: textConfig.curveSegments || 12,
                                        bevelEnabled: textConfig.bevelEnabled || false,
                                        bevelThickness: textConfig.bevelThickness || 0.03,
                                        bevelSize: textConfig.bevelSize || 0.02
                                    };

                                    const geometry = new THREE.TextGeometry(textConfig.content || 'Text', textParams);
                                    geometry.computeBoundingBox();

                                    const material = new THREE.MeshBasicMaterial({
                                        color: new THREE.Color(textConfig.color || '#ffffff')
                                    });

                                    const mesh = new THREE.Mesh(geometry, material);

                                    // Center the text
                                    const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
                                    mesh.position.x = xMid;

                                    // Apply position from marker config if specified
                                    if (config.markers[i].position) {
                                        const pos = config.markers[i].position;
                                        mesh.position.set(
                                            mesh.position.x + (pos.x || 0),
                                            mesh.position.y + (pos.y || 0),
                                            mesh.position.z + (pos.z || 0)
                                        );
                                    }

                                    // Apply rotation from marker config if specified
                                    if (config.markers[i].rotation) {
                                        const rot = config.markers[i].rotation;
                                        mesh.rotation.set(rot.x || 0, rot.y || 0, rot.z || 0);
                                    }

                                    // Store animation if specified (prefer textConfig, fallback to marker level)
                                    if (textConfig.animation) {
                                        mesh.userData.animation = textConfig.animation;
                                    } else if (config.markers[i].animation) {
                                        mesh.userData.animation = config.markers[i].animation;
                                    }

                                    markerRoots[i].add(mesh);
                                    // console.log(`Text content for marker ${i} created`); // Diagnostic message removed
                                }).catch((error) => {
                                    console.error(`Error creating text for marker ${i}:`, error);
                                }));
                            }
                            break;
                        case 'multiplex-3D':
                            // Обробка складного 3D-об'єкта (multiplex-3D)
                            // Підтримка обох форматів: multiplex3D: 1 або multiplex3D: { object_id: 1 }
                            let objectId;
                            if (typeof config.markers[i].multiplex3D === 'number') {
                                objectId = config.markers[i].multiplex3D;
                            } else if (config.markers[i].multiplex3D && config.markers[i].multiplex3D.object_id) {
                                objectId = config.markers[i].multiplex3D.object_id;
                            } else {
                                break;
                            }

                            if (config.markers[i] && objectId) {

                                contentPromises.push(
                                    fetch('config-3D-objects.json')
                                        .then(response => {
                                            if (!response.ok) {
                                                throw new Error('Failed to load config-3D-objects.json');
                                            }
                                            return response.json();
                                        })
                                        .then(data => {
                                            // Знаходимо об'єкт з потрібним object_id
                                            const objectConfig = data.objects.find(obj => obj.object_id === objectId);
                                            if (!objectConfig) {
                                                console.error(`Object with id ${objectId} not found in config-3D-objects.json`);
                                                return;
                                            }

                                            const group = new THREE.Group();
                                            let currentHeight = 0; // Поточна висота для стек-розміщення

                                            // Сортуємо частини за part_id для правильного порядку
                                            const sortedParts = [...objectConfig.part].sort((a, b) => a.part_id - b.part_id);

                                            sortedParts.forEach(partConfig => {
                                                let geometry, material, mesh;

                                                // Створюємо геометрію відповідно до типу
                                                switch(partConfig.type) {
                                                    case 'BoxGeometry':
                                                        geometry = new THREE.BoxGeometry(...partConfig.size);
                                                        break;
                                                    case 'SphereGeometry':
                                                        geometry = new THREE.SphereGeometry(partConfig.radius, partConfig.widthSegments || 32, partConfig.heightSegments || 32);
                                                        break;
                                                    case 'CylinderGeometry':
                                                        geometry = new THREE.CylinderGeometry(
                                                            partConfig.radiusTop || 0.5,
                                                            partConfig.radiusBottom || 0.5,
                                                            partConfig.height || 1,
                                                            partConfig.radialSegments || 32
                                                        );
                                                        break;
                                                    case 'ConeGeometry':
                                                        var coneHeight = partConfig.height || 1;
                                                        geometry = new THREE.ConeGeometry(
                                                            partConfig.radius || 0.5,
                                                            coneHeight,
                                                            partConfig.radialSegments || 32
                                                        );
                                                        // Не зміщуємо геометрію - розміщуємо через позицію меша
                                                        break;
                                                    case 'TorusGeometry':
                                                        geometry = new THREE.TorusGeometry(
                                                            partConfig.radius || 1,
                                                            partConfig.tubeRadius || 0.4,
                                                            partConfig.radialSegments || 16,
                                                            partConfig.tubularSegments || 32
                                                        );
                                                        break;
                                                    default:
                                                        geometry = new THREE.BoxGeometry(1, 1, 1);
                                                }

                                                // Створюємо матеріал з кольором або текстурою
                                                if (partConfig.textureFile) {
                                                    let texture = new THREE.TextureLoader().load(partConfig.textureFile);
                                                    material = new THREE.MeshBasicMaterial({
                                                        map: texture,
                                                        color: new THREE.Color(partConfig.color || '#ffffff')
                                                    });
                                                } else {
                                                    material = new THREE.MeshBasicMaterial({
                                                        color: new THREE.Color(partConfig.color || '#ffffff')
                                                    });
                                                }

                                                // Створюємо меш
                                                mesh = new THREE.Mesh(geometry, material);

                                                // Розміщуємо частину на потрібній висоті
                                                // Варіант 1: Абсолютні координати (positionX, positionY, positionZ) - для складних форм
                                                // Варіант 2: Стек-розміщення (автоматичне) - для простих вертикальних структур
                                                console.log(`Part ${partConfig.part_id}: type=${partConfig.type}, positionY=${partConfig.positionY}, positionX=${partConfig.positionX}, positionZ=${partConfig.positionZ}, currentHeight=${currentHeight}`);
                                                
                                                if (partConfig.positionY !== undefined) {
                                                    // Використовуємо абсолютну позицію Y з конфігурації
                                                    // Додаємо половину висоти об'єкта для центрування
                                                    var partHeight = 0;
                                                    if (partConfig.height) {
                                                        partHeight = partConfig.height;
                                                    } else if (partConfig.size && partConfig.size[1]) {
                                                        partHeight = partConfig.size[1];
                                                    } else if (partConfig.radius) {
                                                        partHeight = partConfig.radius * 2;
                                                    } else if (partConfig.tubeRadius) {
                                                        partHeight = partConfig.tubeRadius * 2;
                                                    }
                                                    mesh.position.y = partConfig.positionY + partHeight / 2;
                                                    console.log(`  -> Абсолютна позиція Y: ${mesh.position.y} (positionY=${partConfig.positionY} + partHeight/2=${partHeight/2})`);
                                                } else if (partConfig.type === 'BoxGeometry' && partConfig.size) {
                                                    // Куб/прямокутник: висота = size[1] (Y-розмір)
                                                    mesh.position.y = currentHeight + partConfig.size[1] / 2;
                                                    currentHeight += partConfig.size[1];
                                                } else if (partConfig.type === 'CylinderGeometry' && partConfig.height) {
                                                    // Циліндр: центр посередині висоти
                                                    mesh.position.y = currentHeight + partConfig.height / 2;
                                                    currentHeight += partConfig.height;
                                                } else if (partConfig.type === 'ConeGeometry' && partConfig.height) {
                                                    // Конус: центр посередині висоти, основа на currentHeight
                                                    mesh.position.y = currentHeight + partConfig.height / 2;
                                                    currentHeight += partConfig.height;
                                                } else if (partConfig.type === 'SphereGeometry' && partConfig.radius) {
                                                    // Сфера: центр в центрі сфери, нижня точка на currentHeight
                                                    mesh.position.y = currentHeight + partConfig.radius;
                                                    currentHeight += 2 * partConfig.radius; // діаметр
                                                } else if (partConfig.type === 'TorusGeometry' && partConfig.tubeRadius) {
                                                    // Тор: центр в центрі тора, нижня точка на currentHeight
                                                    mesh.position.y = currentHeight + partConfig.tubeRadius;
                                                    currentHeight += 2 * partConfig.tubeRadius; // діаметр труби
                                                } else {
                                                    // Для інших фігур або якщо висота не вказана
                                                    mesh.position.y = currentHeight + 0.5;
                                                    currentHeight += 1;
                                                }

                                                // Додаткові координати X, Z (якщо вказані)
                                                if (partConfig.positionX !== undefined) {
                                                    mesh.position.x = partConfig.positionX;
                                                    console.log(`  -> positionX: ${mesh.position.x}`);
                                                }
                                                if (partConfig.positionZ !== undefined) {
                                                    mesh.position.z = partConfig.positionZ;
                                                    console.log(`  -> positionZ: ${mesh.position.z}`);
                                                }

                                                // Застосовуємо обертання, якщо вказане
                                                if (partConfig.rotation) {
                                                    mesh.rotation.set(...partConfig.rotation);
                                                }
                                                // Індивідуальні обертання по осях (якщо вказані окремо)
                                                if (partConfig.rotationX !== undefined) {
                                                    mesh.rotation.x = partConfig.rotationX;
                                                }
                                                if (partConfig.rotationY !== undefined) {
                                                    mesh.rotation.y = partConfig.rotationY;
                                                }
                                                if (partConfig.rotationZ !== undefined) {
                                                    mesh.rotation.z = partConfig.rotationZ;
                                                }

                                                // Зберігаємо анімацію для частини
                                                if (partConfig.animation) {
                                                    mesh.userData.animation = partConfig.animation;
                                                }

                                                group.add(mesh);
                                            });

                                            group.userData.isMultiplex3D = true;
                                            markerRoots[i].add(group);
                                        })
                                        .catch(error => {
                                            console.error(`Error loading multiplex-3D object ${objectId}:`, error);
                                        })
                                );
                            }
                            break;
                        case 'controller':
                            // Create a controller composed of a green body and a red tip (last 10%)
                            const controllerGroup = new THREE.Group();
                            const controllerConfig = markerConfig.controllerConfig;

                            // Long axis along local Z to match tip detection along -Z
                            const totalLength = controllerConfig.totalLength;
                            const tipFraction = controllerConfig.tipFraction;
                            const tipLength = totalLength * tipFraction;
                            const bodyLength = totalLength - tipLength;
                            const crossSection = controllerConfig.crossSection;

                            const controllerBody = new THREE.Mesh(
                                new THREE.BoxGeometry(crossSection, crossSection, bodyLength),
                                new THREE.MeshBasicMaterial({ color: new THREE.Color(controllerConfig.bodyColor) })
                            );
                            controllerBody.userData.isController = true;

                            const controllerTip = new THREE.Mesh(
                                new THREE.BoxGeometry(crossSection, crossSection, tipLength),
                                new THREE.MeshBasicMaterial({ color: new THREE.Color(controllerConfig.tipColor) })
                            );
                            controllerTip.userData.isController = true;

                            // Arrange so that the tip sits at the negative Z end of the combined shape
                            const half = totalLength / 2;
                            controllerTip.position.z = -half + tipLength / 2; // center of tip segment
                            controllerBody.position.z = tipLength / 2;        // center of body segment

                            controllerGroup.add(controllerBody);
                            controllerGroup.add(controllerTip);

                            // Position the whole controller as before (no Y-rotation needed now)
                            controllerGroup.position.y = controllerConfig.positionY;
                            controllerGroup.position.z = -(bodyLength / 2);

                            markerRoots[i].add(controllerGroup);

                            // Use the tip mesh for collision checks
                            controller = controllerTip;
                            break;
                        default:
                            // Якщо жодного контенту не додано, додаємо білу площину.
                            mesh11 = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1),
                                new THREE.MeshBasicMaterial({ color: '#fff' }));
                            // Повертаємо площину
                            mesh11.rotation.x = -Math.PI / 2;
                            // Додаємо площину у контейнер
                            markerRoots[i].add(mesh11);
                            break;
                    }

                    // Якщо є аудіо файли, налаштовуємо їх і додаємо в масив аудіо контенту.
                    if (audioFiles[i]) {
                        // Check if audio should only play on controller intersection
                        let playOnControllerIntersect = config.markers[i] && config.markers[i].playOnControllerIntersect === true;

                        contentPromises.push(new Promise((resolve, reject) => {
                            audioLoader.load(`${audioFiles[i]}`, function (buffer) {
                                // Створюємо аудіо джерело
                                let sound = new THREE.Audio(listener);
                                sound.name = `${audioFiles[i]}`;
                                sound.setBuffer(buffer);
                                // Встановлюємо loop: false для playOnControllerIntersect, інакше true
                                sound.setLoop(!playOnControllerIntersect);
                                // Store sound object with flag
                                let soundData = {
                                    sound: sound,
                                    playOnControllerIntersect: playOnControllerIntersect
                                };
                                if (patternBarcode[i] === -1) {
                                    patternsSound.set(i, soundData);
                                } else {
                                    barcodesSound.set(patternBarcode[i], soundData);
                                }
                                resolve(sound)
                            });
                        }).then((sound) => {
                            // console.log(`File ${sound.name} loaded`) // Diagnostic message removed
                        }))
                    }
                }

                // Ховаємо лоадер після завантаження компонентів
                Promise.all(contentPromises)
                    .then(() => {
                        // console.log('Most of the content loaded') // Diagnostic message removed
                        contentInitialized = true;
                        loader.style.opacity = '0';
                    });

                // Додаємо головний контейнер на сцену
                scene.add(mainContainer);
            }

            function checkController() {
                // Виконуємо перевірку тільки якщо контролер активний (видно камері)
                if (controller && controller.parent && controller.parent.visible) {
                    let intersectedMarkerIndex = null;

                    mainContainer.traverse((object) => {
                        if (object.isMesh && !(object.userData && object.userData.isController)) {
                            if (detectCollisionCubes(object, controller)) {
                                //bject.material.color.set('red');

                                // Find which marker this object belongs to
                                // Для складних об'єктів (групи) потрібно підніматися вгору по ієрархії
                                let parent = object.parent;
                                while (parent) {
                                    for (let i = 0; i < markerRoots.length; i++) {
                                        if (markerRoots[i] === parent) {
                                            intersectedMarkerIndex = i;
                                            break;
                                        }
                                    }
                                    if (intersectedMarkerIndex !== null) break;
                                    parent = parent.parent;
                                }
                            }
                        }
                    });

                    // Update current intersected marker for audio playback
                    currentIntersectedMarker = intersectedMarkerIndex;

                    // Switch to alternative content for intersected marker if it has alternative content
                    if (intersectedMarkerIndex !== null && markerAlternativeContent.has(intersectedMarkerIndex)) {
                        // --- ТАКТИЛЬНИЙ ВІДГУК: вібрація + аудіо клік при дотику ---
                        // Перевіряємо, чи вже був відтворений звук для цього маркера
                        if (!markerSoundPlayed.has(intersectedMarkerIndex)) {
                            var currentTime = performance.now();
                            if (hapticFeedbackEnabled && currentTime - lastHapticTime > hapticCooldown) {
                                // Вібрація для мобільних пристроїв (Vibration API)
                                if (navigator.vibrate) {
                                    navigator.vibrate(15); // Коротка вібрація 15 мс
                                }
                                
                                // Аудіо клік (короткий сигнал)
                                playTouchSound();
                                
                                lastHapticTime = currentTime;

                                // Позначаємо, що звук вже відтворено для цього маркера
                                markerSoundPlayed.add(intersectedMarkerIndex);
                            }
                        }
                        // -------------------------------------------------------------
                        
                        // --- ЗАТРИМКА ЗМІНИ КОНТЕНТУ: чекаємо завершення аудіо (0.5 сек) ---
                        // Альтернативний контент з'явиться після завершення звукового сигналу
                        setTimeout(function() {
                            switchMarkerContent(intersectedMarkerIndex, true);
                        }, 500); // 500 мс = 0.5 секунди
                        // ------------------------------------------------------------------
                    }

                    // Reset all other markers to first content when controller is active but not intersecting them
                    for (let i = 0; i < markerRoots.length; i++) {
                        if (i !== intersectedMarkerIndex && markerContentState.get(i)) {
                            switchMarkerContent(i, false);
                        }
                        // Reset audio played state for markers that are no longer intersected
                        if (i !== intersectedMarkerIndex && markerAudioPlayed.has(i)) {
                            markerAudioPlayed.delete(i);
                        }
                        // Reset sound played state for markers that are no longer intersected
                        if (i !== intersectedMarkerIndex && markerSoundPlayed.has(i)) {
                            markerSoundPlayed.delete(i);
                        }
                        // Cancel audio timeout for markers that are no longer intersected
                        if (i !== intersectedMarkerIndex && markerAudioTimeouts.has(i)) {
                            clearTimeout(markerAudioTimeouts.get(i));
                            markerAudioTimeouts.delete(i);
                        }
                    }
                }
                // Якщо контролер не активний, скидаємо всі об'єкти до білого кольору
                else {
                    // Clear intersected marker when controller is not active
                    currentIntersectedMarker = null;

                    // Reset all markers to first content when controller is not active
                    for (let i = 0; i < markerRoots.length; i++) {
                        if (markerContentState.get(i)) {
                            switchMarkerContent(i, false);
                        }
                        // Reset audio played state for all markers
                        if (markerAudioPlayed.has(i)) {
                            markerAudioPlayed.delete(i);
                        }
                        // Reset sound played state for all markers
                        if (markerSoundPlayed.has(i)) {
                            markerSoundPlayed.delete(i);
                        }
                        // Cancel audio timeout for all markers
                        if (markerAudioTimeouts.has(i)) {
                            clearTimeout(markerAudioTimeouts.get(i));
                            markerAudioTimeouts.delete(i);
                        }
                    }
                }
            }

            // Функція для пошуку перетинів між двома об'єктами сцени
            function detectCollisionCubes(object1, object2, tipFraction = 0.1) {
                // Ensure bounding boxes are available in local space
                object1.geometry.computeBoundingBox();
                object2.geometry.computeBoundingBox();
                object1.updateMatrixWorld();
                object2.updateMatrixWorld();

                // World-space AABB for object1 (full box)
                const box1World = object1.geometry.boundingBox.clone();
                box1World.applyMatrix4(object1.matrixWorld);

                // Start from object2's LOCAL bounding box to define a local-space "tip" region
                const box2Local = object2.geometry.boundingBox.clone();

                // Compute the last `tipFraction` along local -Z (common "forward" in three.js)
                const extentZ = box2Local.max.z - box2Local.min.z;
                const tipLen = Math.max(0, extentZ * tipFraction);

                // Define tip box on the negative Z end: [minZ, minZ + tipLen]
                const tipBoxLocal = box2Local.clone();
                tipBoxLocal.max.z = box2Local.min.z + tipLen;

                // Transform tip box to world space (will become world AABB)
                tipBoxLocal.applyMatrix4(object2.matrixWorld);

                // --- ВІЗУАЛЬНИЙ ВІДГУК: спалах кінчика контролера при дотику ---
                if (box1World.intersectsBox(tipBoxLocal)) {
                    // Короткий спалах кінчика контролера (зміна кольору на білий)
                    if (object2.material && !object2.userData.flashTimeout) {
                        var originalColor = object2.material.color.clone();
                        object2.material.color.set(0xffffff); // Білий спалах

                        // Зберігаємо оригінальний колір для відновлення
                        object2.userData.originalColor = originalColor;

                        // Повернення початкового кольору через 500 мс (синхронно з аудіо)
                        object2.userData.flashTimeout = setTimeout(function() {
                            if (object2.material && object2.userData.originalColor) {
                                object2.material.color.copy(object2.userData.originalColor);
                            }
                            object2.userData.flashTimeout = null;
                        }, 500);
                    }
                }
                // ------------------------------------------------
                
                return box1World.intersectsBox(tipBoxLocal);
            };

            // Функція для діагностики маркерів для Тесту 2
            function trackMarkerDiagnostics(barcodeIdToTrack, currentTime, timeDelta) {
                const markerIndexToTrack = barcodeToMarkerIndex.get(barcodeIdToTrack);

                if (markerIndexToTrack !== undefined) {
                    const markerObject = markerRoots[markerIndexToTrack];

                    if (markerObject.visible) {
                        const isFirstAppearance = !lastMarkerStates[markerIndexToTrack] || !lastMarkerStates[markerIndexToTrack].visible;

                        let positionDelta = 0;
                        let rotationAngleDelta = 0;

                        if (!isFirstAppearance) {
                            const lastState = lastMarkerStates[markerIndexToTrack];
                            // Обчислюємо зміну позиції (дельта)
                            positionDelta = markerObject.position.clone().sub(lastState.position).length();

                            // Розрахунок зміни обертання. Порядок: q_previous_inverse * q_current
                            const lastQuaternionClone = lastState.quaternion.clone().conjugate();
                            const rotationDelta = lastQuaternionClone.multiply(markerObject.quaternion);
                            const vectorLength = Math.sqrt(rotationDelta.x * rotationDelta.x + rotationDelta.y * rotationDelta.y + rotationDelta.z * rotationDelta.z);
                            rotationAngleDelta = 2 * Math.atan2(vectorLength, rotationDelta.w) * (180 / Math.PI);
                        }

                        // Оновлюємо або ініціалізуємо останній стан
                        if (!lastMarkerStates[markerIndexToTrack]) {
                            lastMarkerStates[markerIndexToTrack] = {};
                        }
                        lastMarkerStates[markerIndexToTrack].position = markerObject.position.clone();
                        lastMarkerStates[markerIndexToTrack].quaternion = markerObject.quaternion.clone();
                        lastMarkerStates[markerIndexToTrack].visible = true;

                    } else if (lastMarkerStates[markerIndexToTrack] && lastMarkerStates[markerIndexToTrack].visible) {
                        // Скидаємо стан
                        lastMarkerStates[markerIndexToTrack].visible = false;
                    }
                }
            }

            // Оновлюємо AR контент на кожен кадр
            function update() {
                if (arToolkitSource.ready !== false) {
                    arToolkitContext.update(arToolkitSource.domElement);

                    // --- Розширена діагностика для Тесту 2: Реакція на швидкість руху ---
                    const currentTime = performance.now();
                    const timeDelta = currentTime - (lastUpdateTime || currentTime);
                    lastUpdateTime = currentTime;

                    trackMarkerDiagnostics(1, currentTime, timeDelta);
                    trackMarkerDiagnostics(5, currentTime, timeDelta);
                    // --- КІНЕЦЬ діагностики для Тесту 2 ---

                    // Оновлюємо Aruco маркери (детектуємо один раз на кадр для всіх маркерів)
                    if (arucoControls && arucoControls.length > 0) {
                        // Детектуємо маркери один раз на кадр (як у 4x4-3d.html)
                        var arucoMarkers = ArucoMarkerControls.detectMarkers(arToolkitSource);
                        
                        // Оновлюємо кожен контролер з попередньо детектованими маркерами
                        arucoControls.forEach(controls => {
                            controls.update(arToolkitSource, arucoMarkers);
                        });
                    }

                    if (contentInitialized) {
                        if (barcodesID.length) {
                            barcodesID.forEach((elem, index) => {
                                let soundData = barcodesSound.get(elem);
                                if (!soundData) return;

                                let markerIndex = barcodeToMarkerIndex.get(elem);
                                if (markerIndex === undefined) return;

                                let sound = soundData.sound || soundData; // Support both old format (direct) and new format (object)
                                let playOnControllerIntersect = soundData.playOnControllerIntersect || false;

                                // Get barcode detection status
                                let barcodeMarker = arToolkitContext.arController.barcodeMarkers[elem];
                                let markerDetected = barcodeMarker && barcodeMarker.inCurrent === true;
                                let controllerIntersects = currentIntersectedMarker === markerIndex;

                                // Determine if should play based on flag
                                let shouldPlay = markerDetected;
                                if (playOnControllerIntersect) {
                                    shouldPlay = markerDetected && controllerIntersects;
                                }

                                if (shouldPlay) {
                                    // Play audio only if it hasn't been played yet for this intersection
                                    if (!markerAudioPlayed.has(markerIndex)) {
                                        // --- ЗАТРИМКА АУДІО: синхронізація з появою контенту (0.5 сек) ---
                                        // Аудіо маркера запускається одночасно з появою альтернативного контенту
                                        // Створюємо таймер ТІЛЬКИ якщо ще немає активного таймера для цього маркера
                                        if (!markerAudioTimeouts.has(markerIndex)) {
                                            // Зберігаємо ID таймера для можливого скасування
                                            var timeoutId = setTimeout(function() {
                                                if (sound.nodeName === 'VIDEO') {
                                                    if (sound.paused) {
                                                        sound.play();
                                                        markerAudioPlayed.add(markerIndex);
                                                    }
                                                } else {
                                                    if (!sound.isPlaying) {
                                                        sound.play();
                                                        markerAudioPlayed.add(markerIndex);
                                                    }
                                                }
                                                // Видаляємо таймер після виконання
                                                markerAudioTimeouts.delete(markerIndex);
                                            }, 500); // 500 мс = 0.5 секунди (синхронно з switchMarkerContent)
                                            
                                            markerAudioTimeouts.set(markerIndex, timeoutId);
                                        }
                                        // -----------------------------------------------------------------------
                                    }
                                } else {
                                    // Reset audio state when not intersecting
                                    markerAudioPlayed.delete(markerIndex);
                                    
                                    // --- СКАСУВАННЯ ТАЙМЕРА АУДІО: якщо контролер віддалився ---
                                    // Якщо контролер віддалився до завершення 0.5 сек, скасовуємо аудіо
                                    if (markerAudioTimeouts.has(markerIndex)) {
                                        clearTimeout(markerAudioTimeouts.get(markerIndex));
                                        markerAudioTimeouts.delete(markerIndex);
                                    }
                                    // ----------------------------------------------------------------

                                    if (sound.nodeName === 'VIDEO') {
                                        if (!sound.paused) sound.pause();
                                    } else {
                                        if (sound.isPlaying) {
                                            sound.stop();
                                        }
                                    }
                                    
                                    // Reset alternative content when marker is not detected
                                    if (!markerDetected && markerContentState.get(markerIndex)) {
                                        switchMarkerContent(markerIndex, false);
                                    }
                                }
                            })
                        }
                        if (patternsID.length) {
                            for (let index = 0; index < patternsID.length; index++) {
                                let patternName = patternsID[index];
                                let markerIndex = patternToMarkerIndex.get(patternName);
                                if (markerIndex === undefined) continue;

                                let patternID = (arToolkitContext.arController.patternMarkers[index].markerWidth - 1) * patternIdOffset - 1;
                                patternID = Math.round(patternID);

                                // For patterns, the sound is stored by marker index, not patternID
                                let soundData = patternsSound.get(markerIndex);
                                if (!soundData) return;

                                let sound = soundData.sound || soundData; // Support both old format (direct) and new format (object)
                                let playOnControllerIntersect = soundData.playOnControllerIntersect || false;

                                let markerDetected = arToolkitContext.arController.patternMarkers[index].inCurrent;
                                let controllerIntersects = currentIntersectedMarker === markerIndex;

                                // Determine if should play based on flag
                                let shouldPlay = markerDetected;
                                if (playOnControllerIntersect) {
                                    shouldPlay = markerDetected && controllerIntersects;
                                }

                                if (shouldPlay) {
                                    // --- ЗАТРИМКА АУДІО: синхронізація з появою контенту (0.5 сек) ---
                                    // Аудіо маркера запускається одночасно з появою альтернативного контенту
                                    // Створюємо таймер ТІЛЬКИ якщо ще немає активного таймера для цього маркера
                                    if (!markerAudioTimeouts.has(markerIndex)) {
                                        var timeoutId = setTimeout(function() {
                                            if (sound.nodeName === 'VIDEO') {
                                                if (sound.paused) sound.play();
                                            } else {
                                                if (!sound.isPlaying) sound.play();
                                            }
                                            // Видаляємо таймер після виконання
                                            markerAudioTimeouts.delete(markerIndex);
                                        }, 500); // 500 мс = 0.5 секунди (синхронно з switchMarkerContent)
                                        
                                        markerAudioTimeouts.set(markerIndex, timeoutId);
                                    }
                                    // -----------------------------------------------------------------------
                                } else {
                                    // Скасування таймера аудіо для pattern маркерів
                                    if (markerAudioTimeouts.has(markerIndex)) {
                                        clearTimeout(markerAudioTimeouts.get(markerIndex));
                                        markerAudioTimeouts.delete(markerIndex);
                                    }
                                    
                                    if (sound.nodeName === 'VIDEO') {
                                        if (sound.paused) sound.pause();
                                    } else {
                                        if (sound.isPlaying) sound.stop();
                                    }

                                    // Reset alternative content when marker is not detected
                                    if (!markerDetected && markerContentState.get(markerIndex)) {
                                        switchMarkerContent(markerIndex, false);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Рендерім сцену на кожен кадр
            function render() {
                renderer.render(scene, camera);
            }

            // Функція для анімації примітивів та моделей
            function animateObjects() {
                scene.traverse((object) => {
                    if (object.userData && object.userData.animation) {
                        const anim = object.userData.animation;
                        switch(anim.axis) {
                            case 'x':
                                object.rotation.x += anim.speed;
                                break;
                            case 'y':
                                object.rotation.y += anim.speed;
                                break;
                            case 'z':
                                object.rotation.z += anim.speed;
                                break;
                        }
                    }
                });
            }

            // Запускаємо цикл анімації
            function animate(time) {
                // Прив'язуємо цикл анімації до рендеру браузера
                requestAnimationFrame(animate);
                deltaTime = clock.getDelta();
                totalTime += deltaTime;
                update();
                checkController();
                animateObjects(); // Анімуємо примітиви та моделі
                render();
            }
        }

        // Прибираємо блок після натискання на екран для дозволу аудіо програвання на iOS
        access.addEventListener('click', () => {
            initiateExperience();
            document.body.removeChild(access);
            loader.style.display = 'block';
        });
    </script>

</body>

</html>